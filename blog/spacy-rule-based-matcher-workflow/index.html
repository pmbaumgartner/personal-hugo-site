<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Making the Most of spaCy's Rule-Based Matcher | Peter Baumgartner</title><meta name=keywords content><meta name=description content="TL;DR The Rule-Based Matcher in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you&rsquo;re comfortable with the token attributes needed to write rules. I created a notebook runnable in binder with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project."><meta name=author content><link rel=canonical href=https://www.peterbaumgartner.com/blog/spacy-rule-based-matcher-workflow/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-72692144-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Making the Most of spaCy's Rule-Based Matcher"><meta property="og:description" content="TL;DR The Rule-Based Matcher in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you&rsquo;re comfortable with the token attributes needed to write rules. I created a notebook runnable in binder with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peterbaumgartner.com/blog/spacy-rule-based-matcher-workflow/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-07-18T00:00:00+00:00"><meta property="article:modified_time" content="2019-07-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Making the Most of spaCy's Rule-Based Matcher"><meta name=twitter:description content="TL;DR The Rule-Based Matcher in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you&rsquo;re comfortable with the token attributes needed to write rules. I created a notebook runnable in binder with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"Making the Most of spaCy's Rule-Based Matcher","item":"https://www.peterbaumgartner.com/blog/spacy-rule-based-matcher-workflow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Making the Most of spaCy's Rule-Based Matcher","name":"Making the Most of spaCy\u0027s Rule-Based Matcher","description":"TL;DR The Rule-Based Matcher in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you\u0026rsquo;re comfortable with the token attributes needed to write rules. I created a notebook runnable in binder with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project.","keywords":[],"articleBody":" TL;DR The Rule-Based Matcher in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you’re comfortable with the token attributes needed to write rules. I created a notebook runnable in binder with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project.\nOverview Recently I’ve been spending time with spaCy’s Rule-Based Matcher for a client project. I’ve found it really helpful for our particular case, where we have a small dataset of about 2000 text narratives that document different aspects of a recurring business process meeting. Within the text, we’re looking to identify any issues that might have been documented in the narrative, but not documented in any structured data, and bring them to management’s attention.\nAll the usual tricks were attempted on this data to try and extract something useful: topic modeling (LDA, Embeddings\u003eUMAP\u003eDBSCAN), supervised learning, even labeling thousands of narratives. None of them panned out with anything helpful, mostly due to the size and diversity of the dataset. However, as I was labeling data, I took notes on patterns I was seeing in the data. These patterns were then used to start making rules to surface issues from patterns in the text. As a plus, we are able to explain what the rules do and how they work to stakeholders; some are even simple enough that the stakeholders have provided feedback and ideas to expand the rules.\nI’m assuming that the rule-based matcher is an underused or unknown tool in many practitioner’s NLP toolboxes. It might not be as “cool” as a machine learning approach (though you’ll still training models with my workflow) and requires some linguistics knowledge. Also, in the spaCy ecosystem, it’s a tool I found difficult to make useful in isolation. Rather, the power comes from combining matches with a specific match callback for your problem, extension attributes, and taking advantage of training some pragmatic models to improve your match rules.\nAdvantages and Challenges of Rule-Based Matching ✅ Why rule-based matching is awesome ✅\nNo training data required (good for smaller datasets) Match results give you flexibility for returning relevant sections from your document. i.e. document classification works on whole documents. What if you wanted to find a sentence or phras that was relevant to your problem? The matcher allows you to work with specific sentences and spans after matching. It’s Fast! Easy to integrate into an NLP pipeline Composable and cheap e.g. you could write a bunch of quick, simple rules and use boolean logic on the matches to interesting match combinations. e.g. you can write a really general rule to find relevant documents, then some mutually exclusive sub-rules that operate only on documents that match a general rule. Usually explainable to non-technical stakeholders ⚠️ Why rule-based matching is challenging ⚠️\nGood rules require lots of iteration and experimentation Writing rules requires some linguistics knowledge about parts-of-speech and dependency parsing Token matching operators are greedy Requires frequent sanity checking, testing, and iterating to be sure the matcher is returning what you think it is Requires complementary tools for maximum benefit You’ll probably want to use an on_match callback to work with the full document or a span after a match. Often times the match itself is just the start. We train a text classification model on our matches to help us iterate. I found parameter tuning difficult and training very fragile due to the rare outcome rate for matches. The Workflow Here’s the iterative workflow that I developed to solve these types of problems. The steps are:\nCreate Match Rules. Developing a rule is a way to answer to the following questions: “What is the information I want?”, “How would people write about this information?”, “What attributes on tokens exist to help match the information I want?”. Your answer to the last question may just be the tokens themselves - in my example, we don’t use any advanced token attributes for our first rule, just the lowercase token. For more complex attributes, you might want to put some examples into the displaCy visualizer. It can be helpful to identify a single example from your dataset that you would want to match. From here, write your first rule. Then, think of variations in how people would write about the information you want. I use WordNet and synonyms in my example, but you could also used a pretrained word embedding model to identify synonyms. Match Docs Against Rules. Here you use the matcher to identify documents with matches and store those matches on a custom attribute of that object. This allows you to identify which documents have a match and what that match is. You will want to sanity check your match at this point to verify if it’s capturing what you want. Train a Text Classification Model. Here we’re borrowing from an idea referred to as weak supervision. We’re going to treat all our documents as if we labeled them and our matched documents as if they have a positive label. The idea here is that a trained model will pick up on other patterns of the text that our rules missed. After training, we predict this label on all of our documents. Then, by treating the matched documents as actual labels, we will inspect potential False Negatives from the model predictions. Review False Negatives Filter and sort the documents so that they include documents that did not have matches but have high predicted probabilities. These documents should have language similar to documents that were matched, but you don’t have rules for so they weren’t captured. You’ll need to manually review these and consider again some of the same ideas you thought about in step 1 when originally creating the rules. At this stage, I usually take notes into 3 categories: Rule Additions for things I want to add a rule for, Noted Exclusions for patterns that might be what we’re looking for, but we’ll ignore for this iteration, and Other Ideas for things I thought of while reviewing. Repeat or Finalize Rules. Either repeat steps 2-4 with your new match rules, or finalize the rules you want to match on. Examples Please This is the use case I cover in the notebook.\nLet’s say we work at Amazon, and our boss wants us to explore a potential a new feature for product pages: a list of reasons why people purchased that item. If we assume people write things like I bought this because my old whisk broke in their reviews, we could use the text from product reviews to initially build this feature.\nUsing this workflow, we have a process for automatically extracting these patterns from reviews. As an example, using reviews from a coffee grinder, everything after “Customers by this product …” below was extracted automatically with the matcher.\nCustomers buy this product ... ... as a replacement for a Salton model. ... as a Christmas gift for my son in law. ... as a new coffee maker for serving guests of an annual retreat we host in our home. ... as a spice grinder and are very happy. ... as a christmas gift for a friend and it works great. ... as a spice grinder and a coffee grinder ... because it was cheap and had good reviews, and I have not been disappointed. ... because of the excellent reviews. ... for grinding dry spices. ... for grinding coffee ... to grind beans for cold-brewed coffee. ... to grind spices instead of coffee and it works great. ... to grind xylitol and truvia sweeteners into a powder for cooking. Wrap Up This workflow was the perfect fit for me on a project where I had smaller data, a vague prompt for entering text, and specific language patterns I wanted to extract from text. The pipeline really started to provide value once I understood how all the tools I had available worked together and developed a consistent workflow around them. Next time you’re tackling a problem that has similar constraints or you want to give a new tool a shot, don’t hesitate to reach for the rule-based matcher.\n","wordCount":"1373","inLanguage":"en","datePublished":"2019-07-18T00:00:00Z","dateModified":"2019-07-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/spacy-rule-based-matcher-workflow/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.peterbaumgartner.com/ title=Home><span>Home</span></a></li><li><a href=https://www.peterbaumgartner.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks><span>Notebooks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Making the Most of spaCy's Rule-Based Matcher</h1><div class=post-meta><span title='2019-07-18 00:00:00 +0000 UTC'>July 18, 2019</span></div></header><div class=post-content><meta name=twitter:card content="summary"><meta name=twitter:site content="@pmbaumgartner"><meta name=twitter:creator content="@pmbaumgartner"><meta name=twitter:title content="Making the Most of spaCy's Rule-Based Matcher"><meta name=twitter:description content="A workflow for solving problems by extracting specific language patterns from documents."><meta name=twitter:image content="https://i.postimg.cc/Vv18XQ7z/Pattern-Match-4.png"><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>The <a href=https://spacy.io/usage/rule-based-matching>Rule-Based Matcher</a> in spaCy is awesome when you have small datasets, need to explain your algorithm, locate specific language patterns within a document, favor performance and speed, and you&rsquo;re comfortable with the token attributes needed to write rules. I created a <a href=/notebooks/spacy-rule-based-matcher/>notebook runnable in binder</a> with a worked example on a dataset of product reviews from Amazon that replicates a workflow I successfully used on a recent project.</p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>Recently I&rsquo;ve been spending time with <a href=https://spacy.io/usage/rule-based-matching>spaCy&rsquo;s Rule-Based Matcher</a> for a client project. I&rsquo;ve found it really helpful for our particular case, where we have a small dataset of about 2000 text narratives that document different aspects of a recurring business process meeting. Within the text, we&rsquo;re looking to identify any issues that might have been documented in the narrative, but not documented in any structured data, and bring them to management&rsquo;s attention.</p><p>All the usual tricks were attempted on this data to try and extract something useful: topic modeling (LDA, Embeddings>UMAP>DBSCAN), supervised learning, even labeling thousands of narratives. None of them panned out with anything helpful, mostly due to the size and diversity of the dataset. However, as I was labeling data, I took notes on patterns I was seeing in the data. These patterns were then used to start making rules to surface issues from patterns in the text. As a plus, we are able to explain what the rules do and how they work to stakeholders; some are even simple enough that the stakeholders have provided feedback and ideas to expand the rules.</p><p>I&rsquo;m assuming that the rule-based matcher is an underused or unknown tool in many practitioner&rsquo;s NLP toolboxes. It might not be as &ldquo;cool&rdquo; as a machine learning approach (though you&rsquo;ll still training models with my workflow) and requires some linguistics knowledge. Also, in the spaCy ecosystem, it&rsquo;s a tool I found difficult to make useful in isolation. Rather, the power comes from combining matches with a specific <a href=https://spacy.io/usage/rule-based-matching#on_match>match callback</a> for your problem, <a href=https://spacy.io/usage/processing-pipelines#custom-components-attributes>extension attributes</a>, and taking advantage of <a href=https://spacy.io/usage/training#textcat>training some pragmatic models</a> to improve your match rules.</p><h2 id=advantages-and-challenges-of-rule-based-matching>Advantages and Challenges of Rule-Based Matching<a hidden class=anchor aria-hidden=true href=#advantages-and-challenges-of-rule-based-matching>#</a></h2><p><strong>✅ Why rule-based matching is awesome ✅</strong></p><ul><li>No training data required (good for smaller datasets)</li><li>Match results give you flexibility for returning relevant sections from your document.<ul><li>i.e. document classification works on whole documents. What if you wanted to find a sentence or phras that was relevant to your problem? The matcher allows you to work with specific sentences and spans after matching.</li></ul></li><li>It&rsquo;s Fast!</li><li>Easy to integrate into an NLP pipeline</li><li>Composable and cheap<ul><li>e.g. you could write a bunch of quick, simple rules and use boolean logic on the matches to interesting match combinations.</li><li>e.g. you can write a really general rule to find relevant documents, then some mutually exclusive sub-rules that operate only on documents that match a general rule.</li></ul></li><li>Usually explainable to non-technical stakeholders</li></ul><p><strong>⚠️ Why rule-based matching is challenging ⚠️</strong></p><ul><li>Good rules require lots of iteration and experimentation</li><li>Writing rules requires some linguistics knowledge about parts-of-speech and dependency parsing</li><li>Token matching operators are greedy<ul><li>Requires frequent sanity checking, testing, and iterating to be sure the matcher is returning what you think it is</li></ul></li><li>Requires complementary tools for maximum benefit<ul><li>You&rsquo;ll probably want to use an <code>on_match</code> callback to work with the full document or a span after a match. Often times the match itself is just the start.</li><li>We train a text classification model on our matches to help us iterate. I found parameter tuning difficult and training very fragile due to the rare outcome rate for matches.</li></ul></li></ul><h2 id=the-workflow>The Workflow<a hidden class=anchor aria-hidden=true href=#the-workflow>#</a></h2><p><img loading=lazy src=https://i.postimg.cc/Vv18XQ7z/Pattern-Match-4.png alt="Pattern Match Workflow"></p><p>Here&rsquo;s the iterative workflow that I developed to solve these types of problems. The steps are:</p><ol><li><strong>Create Match Rules.</strong> Developing a rule is a way to answer to the following questions: &ldquo;What is the information I want?&rdquo;, &ldquo;How would people write about this information?&rdquo;, &ldquo;What attributes on tokens exist to help match the information I want?&rdquo;. Your answer to the last question may just be the tokens themselves - in my example, we don&rsquo;t use any advanced token attributes for our first rule, just the lowercase token. For more complex attributes, you might want to put some examples into the <a href=https://explosion.ai/demos/displacy>displaCy</a> visualizer. It can be helpful to identify a single example from your dataset that you would want to match. From here, write your first rule. Then, think of variations in how people would write about the information you want. I use WordNet and synonyms in my example, but you could also used a pretrained word embedding model to identify synonyms.</li><li><strong>Match Docs Against Rules.</strong> Here you use the matcher to identify documents with matches and store those matches on a custom attribute of that object. This allows you to identify which documents have a match and what that match is. You will want to sanity check your match at this point to verify if it&rsquo;s capturing what you want.</li><li><strong>Train a Text Classification Model.</strong> Here we&rsquo;re borrowing from an idea referred to as <a href=http://ai.stanford.edu/blog/weak-supervision/>weak supervision</a>. We&rsquo;re going to treat all our documents as if we labeled them and our matched documents as if they have a positive label. The idea here is that a trained model will pick up on other patterns of the text that our rules missed. After training, we predict this label on all of our documents. Then, by treating the matched documents as <em>actual</em> labels, we will inspect potential <em>False Negatives</em> from the model predictions.</li><li><strong>Review False Negatives</strong> Filter and sort the documents so that they include documents that did not have matches but have high predicted probabilities. These documents should have language similar to documents that were matched, but you don&rsquo;t have rules for so they weren&rsquo;t captured. You&rsquo;ll need to manually review these and consider again some of the same ideas you thought about in step 1 when originally creating the rules. At this stage, I usually take notes into 3 categories: <strong>Rule Additions</strong> for things I want to add a rule for, <strong>Noted Exclusions</strong> for patterns that might be what we&rsquo;re looking for, but we&rsquo;ll ignore for this iteration, and <strong>Other Ideas</strong> for things I thought of while reviewing.</li><li><strong>Repeat or Finalize Rules.</strong> Either repeat steps 2-4 with your new match rules, or finalize the rules you want to match on.</li></ol><h2 id=examples-please>Examples Please<a hidden class=anchor aria-hidden=true href=#examples-please>#</a></h2><p>This is the use case I cover in the notebook.</p><blockquote><p>Let&rsquo;s say we work at Amazon, and our boss wants us to explore a potential a new feature for product pages: a list of reasons why people purchased that item. If we assume people write things like <code>I bought this because my old whisk broke</code> in their reviews, we could use the text from product reviews to initially build this feature.</p></blockquote><p>Using this workflow, we have a process for automatically extracting these patterns from reviews. As an example, using reviews from a coffee grinder, everything after &ldquo;Customers by this product &mldr;&rdquo; below was extracted automatically with the matcher.</p><pre tabindex=0><code>Customers buy this product ...
... as a replacement for a Salton model.
... as a Christmas gift for my son in law.  
... as a new coffee maker for serving guests of an annual retreat we host in our home.  
... as a spice grinder and are very happy.  
... as a christmas gift for a friend and it works great.
... as a spice grinder and a coffee grinder
... because it was cheap and had good reviews, and I have not been disappointed.
... because of the excellent reviews. 
... for grinding dry spices.
... for grinding coffee
... to grind beans for cold-brewed coffee.  
... to grind spices instead of coffee and it works great.  
... to grind xylitol and truvia sweeteners into a powder for cooking.
</code></pre><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>This workflow was the perfect fit for me on a project where I had smaller data, a vague prompt for entering text, and specific language patterns I wanted to extract from text. The pipeline really started to provide value once I understood how all the tools I had available worked together and developed a consistent workflow around them. Next time you&rsquo;re tackling a problem that has similar constraints or you want to give a new tool a shot, don&rsquo;t hesitate to reach for the rule-based matcher.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body><script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>