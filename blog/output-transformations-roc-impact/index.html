<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Impact of Model Output Transformations on ROC | Peter Baumgartner</title><meta name=keywords content><meta name=description content="Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a &lsquo;risk score&rsquo; for an individual that&rsquo;s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime (NIJ)."><meta name=author content><link rel=canonical href=https://www.peterbaumgartner.com/blog/output-transformations-roc-impact/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-72692144-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="The Impact of Model Output Transformations on ROC"><meta property="og:description" content="Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a &lsquo;risk score&rsquo; for an individual that&rsquo;s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime (NIJ)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peterbaumgartner.com/blog/output-transformations-roc-impact/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-05-21T00:00:00+00:00"><meta property="article:modified_time" content="2017-05-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Impact of Model Output Transformations on ROC"><meta name=twitter:description content="Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a &lsquo;risk score&rsquo; for an individual that&rsquo;s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime (NIJ)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"The Impact of Model Output Transformations on ROC","item":"https://www.peterbaumgartner.com/blog/output-transformations-roc-impact/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Impact of Model Output Transformations on ROC","name":"The Impact of Model Output Transformations on ROC","description":"Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a \u0026lsquo;risk score\u0026rsquo; for an individual that\u0026rsquo;s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime (NIJ).","keywords":[],"articleBody":"Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a ‘risk score’ for an individual that’s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime (NIJ). One thing the field seems to have settled on is using area under the receiver operating characteristic (AUC ROC) scores in evaluating the accuracy of these tools. AUC is a sensible evaluation measure since it’s indifferent to base rates and has a straightforward interpretation.\nThe hypothetical example below explains what AUC ROC (Ranking Accuracy) measures.\nCOMPAS \u0026 Risk Assessment Scores In the world of risk assessment, the most well known risk assessment tool is probably COMPAS by Noirthpointe. COMPAS is a black box algorithm that is used to predict recidivism, and was the subject of an investigation by ProPublica as well as a lawsuit in Wisconsin.\nNorthpointe claims that the with the COMPAS tool “AUCs ranged from .68 to .71 in the full sample” for general recidivism, with an “AUC 0.67 for violent recidivism”. In reading these claims, it is important to consider there is some evidence of authorship bias in model evaluation, to the extent that “[…] studies authored by tool designers reported predictive validity findings around two times higher those of investigations reported by independent authors”.\nScores from the COMPAS tool go through several transformations before they end up in a decision maker’s hands. The first output is a raw score from the model itself, which appears to be a normally distributed score. These raw scores are converted to a decile score, which I assume is based on the full range of scores. Finally, Northpointe also provides a mapping of decile scores to qualitative risk levels following this mapping:\n1-4: Low risk 5-7: Medium risk 8+: High risk In evaluating model accuracy, it’s relevant to look at the model accuracy of the information presented to the decision maker. That is, if a judicial official views receives a report with the qualitative risk level (High, Medium, Low) then we should be concerned with the accuracy of those model scores. The the accuracy of the raw score or the decile score doesn’t really matter – the user of this tool never sees this underlying information, though the reported accuracy of the tool may depend on these pre-transformed measures.\nWe’ll evaluate model accuracy at each one of these transformations. Using the data published by ProPublica that contains COMPAS scores and outcomes for individuals in Broward County, Florida.\nOutline This analysis is comprised of 3 parts:\nProcessing \u0026 Exploring the COMPAS dataset from ProPublica Analyzing AUC ROC scores by raw/decile/qualitative transformation Analyzing the general impact of binning on model accuracy 1. Data Processing \u0026 Exploring The final dataset ProPublica uses doesn’t have the raw score, but they do provide the raw COMPAS data, which we will merge into the clean dataset. I couldn’t find a clear ID or case number to merge on at a glance, so we’re merging on first name, last name, and compas screening date. This merging scheme may lead to some discrepancies between the dataset ProPublica used for analysis, but should match most cases in general. In general, I follow their process of filtering observations based on data quality assumptions.\nimport pandas as pd import seaborn as sns; sns.set_context('notebook', font_scale=1.5); import matplotlib.pyplot as plt; plt.style.use('ggplot') import numpy as np import scipy from sklearn.metrics import roc_auc_score %matplotlib inline def read_pp_compas_data(csv_url): d = (pd.read_csv(csv_url, parse_dates=['compas_screening_date']) .query('days_b_screening_arrest \u003c= 30') .query('days_b_screening_arrest \u003e= -30') .query('is_recid != -1') .query('c_charge_degree != \"O\"') .query('score_text != \"N/A\"') .assign(score_text=lambda x: x['score_text'].map({'Low' : 1, 'Medium' : 2, 'High' : 3}), v_score_text=lambda x: x['v_score_text'].map({'Low' : 1, 'Medium' : 2, 'High' : 3})) ) return d compas_recid = read_pp_compas_data('https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years.csv') compas_recid_v = read_pp_compas_data('https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years-violent.csv') compas_recid_simple = compas_recid[['first', 'last', 'compas_screening_date', 'decile_score', 'score_text', 'is_recid']] compas_recid_v_simple = compas_recid_v[['first', 'last', 'compas_screening_date', 'v_decile_score', 'v_score_text', 'is_violent_recid']] compas_scores = pd.merge(compas_recid_simple, compas_recid_v_simple, on=['first', 'last', 'compas_screening_date'], how='outer') compas_scores.head() first last compas_screening_date decile_score score_text is_recid v_decile_score v_score_text is_violent_recid 0 miguel hernandez 2013-08-14 1.0 1.0 0.0 1.0 1.0 0.0 1 kevon dixon 2013-01-27 3.0 1.0 1.0 1.0 1.0 1.0 2 ed philo 2013-04-14 4.0 1.0 1.0 NaN NaN NaN 3 marsha miles 2013-11-30 1.0 1.0 0.0 1.0 1.0 0.0 4 edward riddle 2014-02-19 6.0 2.0 1.0 NaN NaN NaN Read Raw Score Data def read_compas_raw(csv_url): columns = ['LastName', 'FirstName','Screening_Date','RawScore','DisplayText'] colnames = {'FirstName' : 'first', 'LastName' : 'last', 'Screening_Date' : 'compas_screening_date'} d = (pd.read_csv(csv_url, parse_dates=['Screening_Date'], usecols=columns) .rename(columns=colnames) .assign(last=lambda x: x['last'].str.lower(), first=lambda x: x['first'].str.lower()) ) d_recid = d.loc[lambda x: x['DisplayText'] == 'Risk of Recidivism'] d_viol = d.loc[lambda x: x['DisplayText'] == 'Risk of Violence'] d_recid = d_recid.rename(columns={'RawScore' : 'r_raw_score'}) d_viol = d_viol.rename(columns={'RawScore' : 'v_raw_score'}) del d_recid['DisplayText'] del d_viol['DisplayText'] return d_recid, d_viol recid_raw, viol_raw = read_compas_raw('https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-raw.csv') complete_scores = pd.merge(compas_scores, recid_raw, on=['first', 'last', 'compas_screening_date'], how='left') complete_scores = pd.merge(complete_scores, viol_raw, on=['first', 'last', 'compas_screening_date'], how='left') complete_scores.head() first last compas_screening_date decile_score score_text is_recid v_decile_score v_score_text is_violent_recid r_raw_score v_raw_score 0 miguel hernandez 2013-08-14 1.0 1.0 0.0 1.0 1.0 0.0 -2.78 -4.31 1 kevon dixon 2013-01-27 3.0 1.0 1.0 1.0 1.0 1.0 -0.76 -3.07 2 ed philo 2013-04-14 4.0 1.0 1.0 NaN NaN NaN -0.66 -2.26 3 marsha miles 2013-11-30 1.0 1.0 0.0 1.0 1.0 0.0 -1.93 -3.30 4 edward riddle 2014-02-19 6.0 2.0 1.0 NaN NaN NaN -0.16 -2.89 Some final checks complete_scores = complete_scores.dropna(subset=['r_raw_score', 'v_raw_score']) print(\"Has Recid Outcome:\\t\", complete_scores['is_recid'].notnull().sum()) print(\"Has Violent Recid:\\t\", complete_scores['is_violent_recid'].notnull().sum()) Has Recid Outcome:\t6209 Has Violent Recid:\t3998 Explore Distributions of Scores Below we’ll take a look at the distributions of each score to get a better understanding of what the data looks like that’s coming out of the model. We examine the general recidivism cases below, the violent recidivism scores are not pictured.\nRaw Score Distributions def bin_plot(df, values_column, binary_by_column, n_bins=25, bins=None): d_true = df.loc[lambda x: x[binary_by_column] == True][values_column] d_false = df.loc[lambda x: x[binary_by_column] == False][values_column] d_min, d_max = df[values_column].min(), df[values_column].max() if not bins: bins = np.arange(d_min, d_max, (d_max + 1 - d_min) / n_bins) fig, ax = plt.subplots() sns.distplot(d_false, ax=ax, bins=bins, kde=False, norm_hist=True, color='coral') sns.distplot(d_true, ax=ax, bins=bins, kde=False, norm_hist=True, color='blue') sns.plt.title(\"%s by %s\" % (values_column, binary_by_column)); bin_plot(complete_scores, 'r_raw_score', 'is_recid') Raw scores look to be normally distributed and also indicate the model works – there seems to be a significant shift in raw scores in individual who actually recidivated.\nDecile Score Distributions bin_plot(complete_scores, 'decile_score', 'is_recid', n_bins=10) Decile scores are uniform among individuals who did recidivate and right skew among those that did not.\nQualitative Scores bin_plot(complete_scores, 'score_text', 'is_recid', bins=3) Qualitative scores a mapped onto a 1, 2, 3 (low, medium, high) scale. We see a similar pattern to the decile scores since they’re just a collapsed version.\n2. Calculate AUC ROC Data for each Outcome and Transformation Now that the data is merged, we’ll calculate the AUC ROC value for each transformation.\ndef calculate_roc(outcome, score, transformation_name, outcome_name): results = complete_scores[complete_scores[outcome].notnull()] auc = roc_auc_score(results[outcome], results[score]) results = {'transformation' : transformation_name, 'outcome' : outcome_name, 'auc' : auc} return results roc_data = [ calculate_roc('is_recid', 'r_raw_score', 'Raw', 'General Recidivism'), calculate_roc('is_violent_recid', 'v_raw_score', 'Raw', 'Violent Recidivism'), calculate_roc('is_recid', 'decile_score', 'Decile', 'General Recidivism'), calculate_roc('is_violent_recid', 'v_decile_score', 'Decile', 'Violent Recidivism'), calculate_roc('is_recid', 'score_text', 'Qualitative', 'General Recidivism'), calculate_roc('is_violent_recid', 'v_score_text', 'Qualitative', 'Violent Recidivism'), ] roc_df = pd.DataFrame(roc_data) roc_df[['outcome', 'transformation', 'auc']].round(3) outcome transformation auc 0 General Recidivism Raw 0.725 1 Violent Recidivism Raw 0.724 2 General Recidivism Decile 0.714 3 Violent Recidivism Decile 0.716 4 General Recidivism Qualitative 0.678 5 Violent Recidivism Qualitative 0.665 sns.plt.figure(figsize=(6,6)); sns.barplot(y='auc', x='outcome', data=roc_df, hue='transformation') sns.plt.ylim((0.5, 1)) sns.plt.ylabel('AUC ROC'); Accuracy of COMPAS scores by transformation For the COMPAS tool, the accuracy of the model decreases as the number of bins gets smaller. The raw scores have the highest ROC values, but not much higher than the decile scores. In Northpointe’s rebuttal, they achieved AUC scores on the ProPublica sample of 0.69 for general recidivism and 0.68 for violent in evaluating the decile scores. (source, p. 3)\n3. What’s the general case? What happens to ROC scores as deciles are composed out of model scores? To find out, we can generate some simulated data. This simulated data is not from a particular model, but is meant to represent a hypothetical model output of scores for positive and negative cases. For simplicity, we’ll choose a beta distribution for the model output scores and assume our model has some predictive power, where the scores from the model predicting positive classes is generally higher than those where the model predicts a negative outcome.\nIn addition, any cuts of data will be determined from the total distribution of scores. Comparatively, we don’t know the original distribution of COMPAS scores (from when the assessment was developed) to map to the original decile scores – we only use those available in the data.\nWe use a Beta(2,2) distribution to represent the scores of negative cases, and a Beta(3.5, 2) distribution for positive cases. There’s no rationale for the parameters in these distributions except for applying them gives us hypothetical AUC scores in the same range as the COMPAS model.\nWhat does this hypothetical model output look like? Below is a single simulated example from a hypothetical model – the blue indicating the distribution of model scores for positive cases and coral for negative cases.\nSAMPLE_SIZE = 10000 neg = scipy.random.beta(2, 2, size=SAMPLE_SIZE) pos = scipy.random.beta(3.5, 2, size=SAMPLE_SIZE) fig, ax = plt.subplots() bins = np.arange(0, 1, 0.02) sns.distplot(neg, ax=ax, bins=bins, kde=False, norm_hist=True, color='coral') sns.distplot(pos, ax=ax, bins=bins, kde=False, norm_hist=True, color='blue') sns.plt.title(\"Simulated Example\"); Run simulations The simulation below runs 500 simulations with 10000 samples for each simulation, resulting in 10000 simulated ‘positive’ cases and the same for ’negative’ cases. We will apply quantile cuts ranging from 2 to 15 quantiles on the combined positive and negative predictions, as well as the case where no cuts are applied. From each simulated dataset the ROC is calculated.\ndef run_simulations(alpha_pos, alpha_neg, beta, qcuts, sample_size, n_sims): sim_data = [] cuts = list(qcuts) + ['None'] for qcut in cuts: for sim in range(0, n_sims): pos = scipy.random.beta(alpha_pos, beta, size=sample_size) neg = scipy.random.beta(alpha_neg, beta, size=sample_size) roc_scores = np.hstack((neg, pos)) if qcut != 'None': roc_scores = pd.qcut(roc_scores, q=qcut, labels=False) roc_true = np.array([0] * len(neg) + [1] * len(pos)) auc = roc_auc_score(roc_true, roc_scores) data = {'sim' : sim, 'AUC' : auc, 'qcut' : qcut} sim_data.append(data) return pd.DataFrame(sim_data) sim_df = run_simulations(alpha_pos=3.5, alpha_neg=2, beta=2, qcuts=range(2, 16), sample_size=10000, n_sims=500) Plot Data d = pd.DataFrame(sim_df) sns.plt.figure(figsize=(12,8)) sns.violinplot(data=d, x='qcut', y='AUC'); sns.plt.xlabel('Number of Bins') sns.plt.title('Simulated AUC Scores by Number of Bins'); pd.DataFrame(d.groupby('qcut')['AUC'].agg(['median', 'mean', 'std']).round(3)).T qcut 2 3 4 5 6 7 8 9 10 11 12 13 14 15 None median 0.626 0.652 0.662 0.666 0.670 0.671 0.672 0.673 0.673 0.674 0.674 0.674 0.675 0.674 0.676 mean 0.626 0.652 0.662 0.666 0.670 0.671 0.672 0.673 0.673 0.674 0.674 0.674 0.674 0.674 0.676 std 0.003 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 How the binning scheme impacts ROC scores Binning schemes can generate ROC scores lower than the same model with no binning. In the hypothetical example above, the model results with no binning scheme achieved a median AUC of ~0.676, while the models with binary or ternary schemes achieved median AUC values of ~0.626 and ~0.652 respectively. This hypothetical example shows that binning schemes can have a negative impact on AUC values in comparison to the untransformed data.\nSummary The findings above show that when reporting model accuracy with AUC, a reader should be wary of any transformation scheme applied to the model output since that scheme can change the AUC value.\nWe explored the impact of transformation schemes through the COMPAS dataset provided by ProPublica, demonstrating that when the final output of the model is qualitative scores, in comparison to decile scores or raw scores, the model has lower AUC. We then analyzed a hypothetical example to determine what the general case is when differing binning schemes are applied, inferring that binning schemes with a small number of bins in our hypothetical example can result in lower AUC scores.\nIn cases where the output of a model presented to a decision maker is transformed model results, there may be a discrepancy in the accuracy of those presented outputs in comparison to reported accuracy from evaluations. It is important to analyze risk assessments and other models in practice in context of what information is presented to decision makers.\nHelpful Resources Tom Augspurger’s post on method chaining was instrumental in refactoring the data reading steps ","wordCount":"2076","inLanguage":"en","datePublished":"2017-05-21T00:00:00Z","dateModified":"2017-05-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/output-transformations-roc-impact/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.peterbaumgartner.com/ title=Home><span>Home</span></a></li><li><a href=https://www.peterbaumgartner.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks><span>Notebooks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The Impact of Model Output Transformations on ROC</h1><div class=post-meta><span title='2017-05-21 00:00:00 +0000 UTC'>May 21, 2017</span></div></header><div class=post-content><p>Risk Assessment tools are currently used to assist in decision-making at several points in the criminal justice system. These tools take in some data about an individual and to provide a &lsquo;risk score&rsquo; for an individual that&rsquo;s reflective of their likelihood of committing a specific behavior in the future. A standard outcome of interest is recidivism, or <code>a person's relapse into criminal behavior, often after the person receives sanctions or undergoes intervention for a previous crime</code> (<a href=https://www.nij.gov/topics/corrections/recidivism/Pages/welcome.aspx>NIJ</a>). One thing the field seems to have settled on is using area under the receiver operating characteristic (AUC ROC) scores in evaluating the accuracy of these tools. AUC is a sensible evaluation measure since it&rsquo;s indifferent to base rates and has a straightforward interpretation.</p><p>The hypothetical example below explains what AUC ROC (Ranking Accuracy) measures.</p><img src=https://cdn.pbrd.co/images/90KfTPdS0.png width=600><h2 id=compas--risk-assessment-scores>COMPAS & Risk Assessment Scores<a hidden class=anchor aria-hidden=true href=#compas--risk-assessment-scores>#</a></h2><p>In the world of risk assessment, the most well known risk assessment tool is probably COMPAS by Noirthpointe. COMPAS is a black box algorithm that is used to predict recidivism, and was the subject of an <a href=https://www.propublica.org/article/how-we-analyzed-the-compas-recidivism-algorithm>investigation by ProPublica</a> as well as a <a href=https://www.nytimes.com/2016/06/23/us/backlash-in-wisconsin-against-using-data-to-foretell-defendants-futures.html>lawsuit in Wisconsin</a>.</p><p>Northpointe <a href=http://www.northpointeinc.com/files/downloads/FAQ_Document.pdf>claims</a> that the with the COMPAS tool &ldquo;AUCs ranged from .68 to .71 in the full sample&rdquo; for general recidivism, with an &ldquo;AUC 0.67 for violent recidivism&rdquo;. In reading these claims, it is important to consider there is <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0072484">some evidence of authorship bias</a> in model evaluation, to the extent that &ldquo;[&mldr;] studies authored by tool designers reported predictive validity findings around two times higher those of investigations reported by independent authors&rdquo;.</p><p>Scores from the COMPAS tool go through several transformations before they end up in a decision maker&rsquo;s hands. The first output is a <code>raw score</code> from the model itself, which appears to be a normally distributed score. These raw scores are converted to a <code>decile score</code>, which I assume is based on the full range of scores. Finally, Northpointe also provides a mapping of decile scores to qualitative risk levels following this mapping:</p><ul><li><strong>1-4</strong>: Low risk</li><li><strong>5-7</strong>: Medium risk</li><li><strong>8+</strong>: High risk</li></ul><p>In evaluating model accuracy, it&rsquo;s relevant to look at the model accuracy of the information presented to the decision maker. That is, if a judicial official views receives a report with the qualitative risk level (High, Medium, Low) then we should be concerned with the accuracy of those model scores. The the accuracy of the <code>raw score</code> or the <code>decile score</code> doesn&rsquo;t really matter &ndash; the user of this tool never sees this underlying information, though the reported accuracy of the tool may depend on these pre-transformed measures.</p><p>We&rsquo;ll evaluate model accuracy at each one of these transformations. Using the <a href=https://github.com/propublica/compas-analysis/>data</a> published by ProPublica that contains COMPAS scores and outcomes for individuals in Broward County, Florida.</p><h2 id=outline>Outline<a hidden class=anchor aria-hidden=true href=#outline>#</a></h2><p>This analysis is comprised of 3 parts:</p><ol><li>Processing & Exploring the COMPAS dataset from ProPublica</li><li>Analyzing AUC ROC scores by raw/decile/qualitative transformation</li><li>Analyzing the general impact of binning on model accuracy</li></ol><h2 id=1-data-processing--exploring>1. Data Processing & Exploring<a hidden class=anchor aria-hidden=true href=#1-data-processing--exploring>#</a></h2><p>The final dataset ProPublica uses doesn&rsquo;t have the raw score, but they do provide the raw COMPAS data, which we will merge into the clean dataset. I couldn&rsquo;t find a clear ID or case number to merge on at a glance, so we&rsquo;re merging on <code>first name</code>, <code>last name</code>, and <code>compas screening date</code>. This merging scheme may lead to some discrepancies between the dataset ProPublica used for analysis, but should match most cases in general. In general, I follow <a href=https://github.com/propublica/compas-analysis/blob/master/Compas%20Analysis.ipynb>their process</a> of filtering observations based on data quality assumptions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> seaborn <span style=color:#66d9ef>as</span> sns; sns<span style=color:#f92672>.</span>set_context(<span style=color:#e6db74>&#39;notebook&#39;</span>, font_scale<span style=color:#f92672>=</span><span style=color:#ae81ff>1.5</span>);
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt; plt<span style=color:#f92672>.</span>style<span style=color:#f92672>.</span>use(<span style=color:#e6db74>&#39;ggplot&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> scipy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> sklearn.metrics <span style=color:#f92672>import</span> roc_auc_score
</span></span><span style=display:flex><span><span style=color:#f92672>%</span>matplotlib inline
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_pp_compas_data</span>(csv_url):
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> (pd<span style=color:#f92672>.</span>read_csv(csv_url, parse_dates<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;compas_screening_date&#39;</span>])
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#39;days_b_screening_arrest &lt;= 30&#39;</span>)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#39;days_b_screening_arrest &gt;= -30&#39;</span>)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#39;is_recid != -1&#39;</span>)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#39;c_charge_degree != &#34;O&#34;&#39;</span>)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>query(<span style=color:#e6db74>&#39;score_text != &#34;N/A&#34;&#39;</span>)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>assign(score_text<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;score_text&#39;</span>]<span style=color:#f92672>.</span>map({<span style=color:#e6db74>&#39;Low&#39;</span> : <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;Medium&#39;</span> : <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;High&#39;</span> : <span style=color:#ae81ff>3</span>}),
</span></span><span style=display:flex><span>                 v_score_text<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;v_score_text&#39;</span>]<span style=color:#f92672>.</span>map({<span style=color:#e6db74>&#39;Low&#39;</span> : <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;Medium&#39;</span> : <span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;High&#39;</span> : <span style=color:#ae81ff>3</span>}))
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> d
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>compas_recid <span style=color:#f92672>=</span> read_pp_compas_data(<span style=color:#e6db74>&#39;https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years.csv&#39;</span>)
</span></span><span style=display:flex><span>compas_recid_v <span style=color:#f92672>=</span> read_pp_compas_data(<span style=color:#e6db74>&#39;https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-two-years-violent.csv&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>compas_recid_simple <span style=color:#f92672>=</span> compas_recid[[<span style=color:#e6db74>&#39;first&#39;</span>, <span style=color:#e6db74>&#39;last&#39;</span>, <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>, <span style=color:#e6db74>&#39;decile_score&#39;</span>, <span style=color:#e6db74>&#39;score_text&#39;</span>, <span style=color:#e6db74>&#39;is_recid&#39;</span>]]
</span></span><span style=display:flex><span>compas_recid_v_simple <span style=color:#f92672>=</span> compas_recid_v[[<span style=color:#e6db74>&#39;first&#39;</span>, <span style=color:#e6db74>&#39;last&#39;</span>, <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>, <span style=color:#e6db74>&#39;v_decile_score&#39;</span>, <span style=color:#e6db74>&#39;v_score_text&#39;</span>, <span style=color:#e6db74>&#39;is_violent_recid&#39;</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>compas_scores <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>merge(compas_recid_simple, compas_recid_v_simple, on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;first&#39;</span>, <span style=color:#e6db74>&#39;last&#39;</span>, <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>], how<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;outer&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>compas_scores<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>first</th><th>last</th><th>compas_screening_date</th><th>decile_score</th><th>score_text</th><th>is_recid</th><th>v_decile_score</th><th>v_score_text</th><th>is_violent_recid</th></tr></thead><tbody><tr><th>0</th><td>miguel</td><td>hernandez</td><td>2013-08-14</td><td>1.0</td><td>1.0</td><td>0.0</td><td>1.0</td><td>1.0</td><td>0.0</td></tr><tr><th>1</th><td>kevon</td><td>dixon</td><td>2013-01-27</td><td>3.0</td><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><th>2</th><td>ed</td><td>philo</td><td>2013-04-14</td><td>4.0</td><td>1.0</td><td>1.0</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>3</th><td>marsha</td><td>miles</td><td>2013-11-30</td><td>1.0</td><td>1.0</td><td>0.0</td><td>1.0</td><td>1.0</td><td>0.0</td></tr><tr><th>4</th><td>edward</td><td>riddle</td><td>2014-02-19</td><td>6.0</td><td>2.0</td><td>1.0</td><td>NaN</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h3 id=read-raw-score-data>Read Raw Score Data<a hidden class=anchor aria-hidden=true href=#read-raw-score-data>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_compas_raw</span>(csv_url):
</span></span><span style=display:flex><span>    columns <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;LastName&#39;</span>, <span style=color:#e6db74>&#39;FirstName&#39;</span>,<span style=color:#e6db74>&#39;Screening_Date&#39;</span>,<span style=color:#e6db74>&#39;RawScore&#39;</span>,<span style=color:#e6db74>&#39;DisplayText&#39;</span>]
</span></span><span style=display:flex><span>    colnames <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;FirstName&#39;</span> : <span style=color:#e6db74>&#39;first&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;LastName&#39;</span> : <span style=color:#e6db74>&#39;last&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;Screening_Date&#39;</span> : <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> (pd<span style=color:#f92672>.</span>read_csv(csv_url, parse_dates<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;Screening_Date&#39;</span>], usecols<span style=color:#f92672>=</span>columns)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>rename(columns<span style=color:#f92672>=</span>colnames)
</span></span><span style=display:flex><span>         <span style=color:#f92672>.</span>assign(last<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;last&#39;</span>]<span style=color:#f92672>.</span>str<span style=color:#f92672>.</span>lower(),
</span></span><span style=display:flex><span>                first<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;first&#39;</span>]<span style=color:#f92672>.</span>str<span style=color:#f92672>.</span>lower())
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    d_recid <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>loc[<span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;DisplayText&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Risk of Recidivism&#39;</span>]
</span></span><span style=display:flex><span>    d_viol <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>loc[<span style=color:#66d9ef>lambda</span> x: x[<span style=color:#e6db74>&#39;DisplayText&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Risk of Violence&#39;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    d_recid <span style=color:#f92672>=</span> d_recid<span style=color:#f92672>.</span>rename(columns<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;RawScore&#39;</span> : <span style=color:#e6db74>&#39;r_raw_score&#39;</span>})
</span></span><span style=display:flex><span>    d_viol <span style=color:#f92672>=</span> d_viol<span style=color:#f92672>.</span>rename(columns<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;RawScore&#39;</span> : <span style=color:#e6db74>&#39;v_raw_score&#39;</span>})
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>del</span> d_recid[<span style=color:#e6db74>&#39;DisplayText&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>del</span> d_viol[<span style=color:#e6db74>&#39;DisplayText&#39;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> d_recid, d_viol
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>recid_raw, viol_raw <span style=color:#f92672>=</span> read_compas_raw(<span style=color:#e6db74>&#39;https://raw.githubusercontent.com/propublica/compas-analysis/master/compas-scores-raw.csv&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>complete_scores <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>merge(compas_scores, recid_raw, on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;first&#39;</span>, <span style=color:#e6db74>&#39;last&#39;</span>, <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>], how<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;left&#39;</span>)
</span></span><span style=display:flex><span>complete_scores <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>merge(complete_scores, viol_raw, on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;first&#39;</span>, <span style=color:#e6db74>&#39;last&#39;</span>, <span style=color:#e6db74>&#39;compas_screening_date&#39;</span>], how<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;left&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>complete_scores<span style=color:#f92672>.</span>head()
</span></span></code></pre></div><div><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>first</th><th>last</th><th>compas_screening_date</th><th>decile_score</th><th>score_text</th><th>is_recid</th><th>v_decile_score</th><th>v_score_text</th><th>is_violent_recid</th><th>r_raw_score</th><th>v_raw_score</th></tr></thead><tbody><tr><th>0</th><td>miguel</td><td>hernandez</td><td>2013-08-14</td><td>1.0</td><td>1.0</td><td>0.0</td><td>1.0</td><td>1.0</td><td>0.0</td><td>-2.78</td><td>-4.31</td></tr><tr><th>1</th><td>kevon</td><td>dixon</td><td>2013-01-27</td><td>3.0</td><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td><td>-0.76</td><td>-3.07</td></tr><tr><th>2</th><td>ed</td><td>philo</td><td>2013-04-14</td><td>4.0</td><td>1.0</td><td>1.0</td><td>NaN</td><td>NaN</td><td>NaN</td><td>-0.66</td><td>-2.26</td></tr><tr><th>3</th><td>marsha</td><td>miles</td><td>2013-11-30</td><td>1.0</td><td>1.0</td><td>0.0</td><td>1.0</td><td>1.0</td><td>0.0</td><td>-1.93</td><td>-3.30</td></tr><tr><th>4</th><td>edward</td><td>riddle</td><td>2014-02-19</td><td>6.0</td><td>2.0</td><td>1.0</td><td>NaN</td><td>NaN</td><td>NaN</td><td>-0.16</td><td>-2.89</td></tr></tbody></table></div><h4 id=some-final-checks>Some final checks<a hidden class=anchor aria-hidden=true href=#some-final-checks>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>complete_scores <span style=color:#f92672>=</span> complete_scores<span style=color:#f92672>.</span>dropna(subset<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;r_raw_score&#39;</span>, <span style=color:#e6db74>&#39;v_raw_score&#39;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Has Recid Outcome:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>, complete_scores[<span style=color:#e6db74>&#39;is_recid&#39;</span>]<span style=color:#f92672>.</span>notnull()<span style=color:#f92672>.</span>sum())
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Has Violent Recid:</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>, complete_scores[<span style=color:#e6db74>&#39;is_violent_recid&#39;</span>]<span style=color:#f92672>.</span>notnull()<span style=color:#f92672>.</span>sum())
</span></span></code></pre></div><pre><code>Has Recid Outcome:	 6209
Has Violent Recid:	 3998
</code></pre><h3 id=explore-distributions-of-scores>Explore Distributions of Scores<a hidden class=anchor aria-hidden=true href=#explore-distributions-of-scores>#</a></h3><p>Below we&rsquo;ll take a look at the distributions of each score to get a better understanding of what the data looks like that&rsquo;s coming out of the model. We examine the general recidivism cases below, the violent recidivism scores are not pictured.</p><h4 id=raw-score-distributions>Raw Score Distributions<a hidden class=anchor aria-hidden=true href=#raw-score-distributions>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bin_plot</span>(df, values_column, binary_by_column, n_bins<span style=color:#f92672>=</span><span style=color:#ae81ff>25</span>, bins<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    d_true <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#66d9ef>lambda</span> x: x[binary_by_column] <span style=color:#f92672>==</span> <span style=color:#66d9ef>True</span>][values_column]
</span></span><span style=display:flex><span>    d_false <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>loc[<span style=color:#66d9ef>lambda</span> x: x[binary_by_column] <span style=color:#f92672>==</span> <span style=color:#66d9ef>False</span>][values_column]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    d_min, d_max <span style=color:#f92672>=</span> df[values_column]<span style=color:#f92672>.</span>min(), df[values_column]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> bins:
</span></span><span style=display:flex><span>        bins <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(d_min, d_max, (d_max <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> d_min) <span style=color:#f92672>/</span> n_bins)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    fig, ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots()
</span></span><span style=display:flex><span>    sns<span style=color:#f92672>.</span>distplot(d_false, ax<span style=color:#f92672>=</span>ax, bins<span style=color:#f92672>=</span>bins, kde<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, norm_hist<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;coral&#39;</span>)
</span></span><span style=display:flex><span>    sns<span style=color:#f92672>.</span>distplot(d_true, ax<span style=color:#f92672>=</span>ax, bins<span style=color:#f92672>=</span>bins, kde<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, norm_hist<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;blue&#39;</span>)
</span></span><span style=display:flex><span>    sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> by </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (values_column, binary_by_column));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>bin_plot(complete_scores, <span style=color:#e6db74>&#39;r_raw_score&#39;</span>, <span style=color:#e6db74>&#39;is_recid&#39;</span>)
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_16_0.png alt=png></p><p>Raw scores look to be normally distributed and also indicate the model works &ndash; there seems to be a significant shift in raw scores in individual who actually recidivated.</p><h4 id=decile-score-distributions>Decile Score Distributions<a hidden class=anchor aria-hidden=true href=#decile-score-distributions>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bin_plot(complete_scores, <span style=color:#e6db74>&#39;decile_score&#39;</span>, <span style=color:#e6db74>&#39;is_recid&#39;</span>, n_bins<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_18_0.png alt=png></p><p>Decile scores are uniform among individuals who did recidivate and right skew among those that did not.</p><h4 id=qualitative-scores>Qualitative Scores<a hidden class=anchor aria-hidden=true href=#qualitative-scores>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bin_plot(complete_scores, <span style=color:#e6db74>&#39;score_text&#39;</span>, <span style=color:#e6db74>&#39;is_recid&#39;</span>, bins<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_20_0.png alt=png></p><p>Qualitative scores a mapped onto a 1, 2, 3 (low, medium, high) scale. We see a similar pattern to the decile scores since they&rsquo;re just a collapsed version.</p><h2 id=2-calculate-auc-roc-data-for-each-outcome-and-transformation>2. Calculate AUC ROC Data for each Outcome and Transformation<a hidden class=anchor aria-hidden=true href=#2-calculate-auc-roc-data-for-each-outcome-and-transformation>#</a></h2><p>Now that the data is merged, we&rsquo;ll calculate the AUC ROC value for each transformation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_roc</span>(outcome, score, transformation_name, outcome_name):
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> complete_scores[complete_scores[outcome]<span style=color:#f92672>.</span>notnull()]
</span></span><span style=display:flex><span>    auc <span style=color:#f92672>=</span> roc_auc_score(results[outcome], results[score])
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;transformation&#39;</span> : transformation_name,
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;outcome&#39;</span> : outcome_name,
</span></span><span style=display:flex><span>               <span style=color:#e6db74>&#39;auc&#39;</span> : auc}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> results
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>roc_data <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_recid&#39;</span>, <span style=color:#e6db74>&#39;r_raw_score&#39;</span>, <span style=color:#e6db74>&#39;Raw&#39;</span>, <span style=color:#e6db74>&#39;General Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_violent_recid&#39;</span>, <span style=color:#e6db74>&#39;v_raw_score&#39;</span>, <span style=color:#e6db74>&#39;Raw&#39;</span>, <span style=color:#e6db74>&#39;Violent Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_recid&#39;</span>, <span style=color:#e6db74>&#39;decile_score&#39;</span>, <span style=color:#e6db74>&#39;Decile&#39;</span>, <span style=color:#e6db74>&#39;General Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_violent_recid&#39;</span>, <span style=color:#e6db74>&#39;v_decile_score&#39;</span>, <span style=color:#e6db74>&#39;Decile&#39;</span>, <span style=color:#e6db74>&#39;Violent Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_recid&#39;</span>, <span style=color:#e6db74>&#39;score_text&#39;</span>, <span style=color:#e6db74>&#39;Qualitative&#39;</span>, <span style=color:#e6db74>&#39;General Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    calculate_roc(<span style=color:#e6db74>&#39;is_violent_recid&#39;</span>, <span style=color:#e6db74>&#39;v_score_text&#39;</span>, <span style=color:#e6db74>&#39;Qualitative&#39;</span>, <span style=color:#e6db74>&#39;Violent Recidivism&#39;</span>),
</span></span><span style=display:flex><span>    ]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>roc_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(roc_data)
</span></span><span style=display:flex><span>roc_df[[<span style=color:#e6db74>&#39;outcome&#39;</span>, <span style=color:#e6db74>&#39;transformation&#39;</span>, <span style=color:#e6db74>&#39;auc&#39;</span>]]<span style=color:#f92672>.</span>round(<span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><div><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>outcome</th><th>transformation</th><th>auc</th></tr></thead><tbody><tr><th>0</th><td>General Recidivism</td><td>Raw</td><td>0.725</td></tr><tr><th>1</th><td>Violent Recidivism</td><td>Raw</td><td>0.724</td></tr><tr><th>2</th><td>General Recidivism</td><td>Decile</td><td>0.714</td></tr><tr><th>3</th><td>Violent Recidivism</td><td>Decile</td><td>0.716</td></tr><tr><th>4</th><td>General Recidivism</td><td>Qualitative</td><td>0.678</td></tr><tr><th>5</th><td>Violent Recidivism</td><td>Qualitative</td><td>0.665</td></tr></tbody></table></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>barplot(y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;auc&#39;</span>, x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;outcome&#39;</span>, data<span style=color:#f92672>=</span>roc_df, hue<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;transformation&#39;</span>)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>ylim((<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#39;AUC ROC&#39;</span>);
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_25_0.png alt=png></p><h3 id=accuracy-of-compas-scores-by-transformation>Accuracy of COMPAS scores by transformation<a hidden class=anchor aria-hidden=true href=#accuracy-of-compas-scores-by-transformation>#</a></h3><p>For the COMPAS tool, the accuracy of the model decreases as the number of bins gets smaller. The raw scores have the highest ROC values, but not much higher than the decile scores. In Northpointe&rsquo;s rebuttal, they achieved AUC scores on the ProPublica sample of 0.69 for general recidivism and 0.68 for violent in evaluating the decile scores. (<a href=http://go.volarisgroup.com/rs/430-MBX-989/images/ProPublica_Commentary_Final_070616.pdf>source, p. 3</a>)</p><h2 id=3-whats-the-general-case>3. What&rsquo;s the general case?<a hidden class=anchor aria-hidden=true href=#3-whats-the-general-case>#</a></h2><p>What happens to ROC scores as deciles are composed out of model scores? To find out, we can generate some simulated data. This simulated data is not from a particular model, but is meant to represent a hypothetical model output of scores for positive and negative cases. For simplicity, we&rsquo;ll choose a beta distribution for the model output scores and assume our model has some predictive power, where the scores from the model predicting positive classes is generally higher than those where the model predicts a negative outcome.</p><p>In addition, any cuts of data will be determined from the total distribution of scores. Comparatively, we don&rsquo;t know the original distribution of COMPAS scores (from when the assessment was developed) to map to the original decile scores &ndash; we only use those available in the data.</p><p>We use a <code>Beta(2,2)</code> distribution to represent the scores of negative cases, and a <code>Beta(3.5, 2)</code> distribution for positive cases. There&rsquo;s no rationale for the parameters in these distributions except for applying them gives us hypothetical AUC scores in the same range as the COMPAS model.</p><h3 id=what-does-this-hypothetical-model-output-look-like>What does this hypothetical model output look like?<a hidden class=anchor aria-hidden=true href=#what-does-this-hypothetical-model-output-look-like>#</a></h3><p>Below is a single simulated example from a hypothetical model &ndash; the blue indicating the distribution of model scores for positive cases and coral for negative cases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>SAMPLE_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>neg <span style=color:#f92672>=</span> scipy<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>beta(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, size<span style=color:#f92672>=</span>SAMPLE_SIZE)
</span></span><span style=display:flex><span>pos <span style=color:#f92672>=</span> scipy<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>beta(<span style=color:#ae81ff>3.5</span>, <span style=color:#ae81ff>2</span>, size<span style=color:#f92672>=</span>SAMPLE_SIZE)
</span></span><span style=display:flex><span>fig, ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots()
</span></span><span style=display:flex><span>bins <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.02</span>)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>distplot(neg, ax<span style=color:#f92672>=</span>ax, bins<span style=color:#f92672>=</span>bins, kde<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, norm_hist<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;coral&#39;</span>)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>distplot(pos, ax<span style=color:#f92672>=</span>ax, bins<span style=color:#f92672>=</span>bins, kde<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, norm_hist<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;blue&#39;</span>)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#34;Simulated Example&#34;</span>);
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_29_0.png alt=png></p><h3 id=run-simulations>Run simulations<a hidden class=anchor aria-hidden=true href=#run-simulations>#</a></h3><p>The simulation below runs 500 simulations with 10000 samples for each simulation, resulting in 10000 simulated &lsquo;positive&rsquo; cases and the same for &rsquo;negative&rsquo; cases. We will apply quantile cuts ranging from 2 to 15 quantiles on the combined positive and negative predictions, as well as the case where no cuts are applied. From each simulated dataset the ROC is calculated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_simulations</span>(alpha_pos, alpha_neg, beta, qcuts, sample_size, n_sims):
</span></span><span style=display:flex><span>    sim_data <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    cuts <span style=color:#f92672>=</span> list(qcuts) <span style=color:#f92672>+</span> [<span style=color:#e6db74>&#39;None&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> qcut <span style=color:#f92672>in</span> cuts:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> sim <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, n_sims):
</span></span><span style=display:flex><span>            pos <span style=color:#f92672>=</span> scipy<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>beta(alpha_pos, beta, size<span style=color:#f92672>=</span>sample_size)
</span></span><span style=display:flex><span>            neg <span style=color:#f92672>=</span> scipy<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>beta(alpha_neg, beta, size<span style=color:#f92672>=</span>sample_size)
</span></span><span style=display:flex><span>            roc_scores <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>hstack((neg, pos))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> qcut <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;None&#39;</span>:
</span></span><span style=display:flex><span>                roc_scores <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>qcut(roc_scores, q<span style=color:#f92672>=</span>qcut, labels<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>            roc_true <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> len(neg) <span style=color:#f92672>+</span> [<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> len(pos))
</span></span><span style=display:flex><span>            auc <span style=color:#f92672>=</span> roc_auc_score(roc_true, roc_scores)
</span></span><span style=display:flex><span>            data <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;sim&#39;</span> : sim, <span style=color:#e6db74>&#39;AUC&#39;</span> : auc, <span style=color:#e6db74>&#39;qcut&#39;</span> : qcut}
</span></span><span style=display:flex><span>            sim_data<span style=color:#f92672>.</span>append(data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pd<span style=color:#f92672>.</span>DataFrame(sim_data)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sim_df <span style=color:#f92672>=</span> run_simulations(alpha_pos<span style=color:#f92672>=</span><span style=color:#ae81ff>3.5</span>, alpha_neg<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, beta<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, qcuts<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>16</span>), sample_size<span style=color:#f92672>=</span><span style=color:#ae81ff>10000</span>, n_sims<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span>)
</span></span></code></pre></div><h3 id=plot-data>Plot Data<a hidden class=anchor aria-hidden=true href=#plot-data>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>d <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(sim_df)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>12</span>,<span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>violinplot(data<span style=color:#f92672>=</span>d, x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;qcut&#39;</span>, y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;AUC&#39;</span>);
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#39;Number of Bins&#39;</span>)
</span></span><span style=display:flex><span>sns<span style=color:#f92672>.</span>plt<span style=color:#f92672>.</span>title(<span style=color:#e6db74>&#39;Simulated AUC Scores by Number of Bins&#39;</span>);
</span></span></code></pre></div><p><img loading=lazy src=/images/Calculating%20ROC%20before%20and%20after%20transformations_34_1.png alt=png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>pd<span style=color:#f92672>.</span>DataFrame(d<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;qcut&#39;</span>)[<span style=color:#e6db74>&#39;AUC&#39;</span>]<span style=color:#f92672>.</span>agg([<span style=color:#e6db74>&#39;median&#39;</span>, <span style=color:#e6db74>&#39;mean&#39;</span>, <span style=color:#e6db74>&#39;std&#39;</span>])<span style=color:#f92672>.</span>round(<span style=color:#ae81ff>3</span>))<span style=color:#f92672>.</span>T
</span></span></code></pre></div><div><table border=1 class=dataframe><thead><tr style=text-align:right><th>qcut</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>None</th></tr></thead><tbody><tr><th>median</th><td>0.626</td><td>0.652</td><td>0.662</td><td>0.666</td><td>0.670</td><td>0.671</td><td>0.672</td><td>0.673</td><td>0.673</td><td>0.674</td><td>0.674</td><td>0.674</td><td>0.675</td><td>0.674</td><td>0.676</td></tr><tr><th>mean</th><td>0.626</td><td>0.652</td><td>0.662</td><td>0.666</td><td>0.670</td><td>0.671</td><td>0.672</td><td>0.673</td><td>0.673</td><td>0.674</td><td>0.674</td><td>0.674</td><td>0.674</td><td>0.674</td><td>0.676</td></tr><tr><th>std</th><td>0.003</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td><td>0.004</td></tr></tbody></table></div><h3 id=how-the-binning-scheme-impacts-roc-scores>How the binning scheme impacts ROC scores<a hidden class=anchor aria-hidden=true href=#how-the-binning-scheme-impacts-roc-scores>#</a></h3><p>Binning schemes can generate ROC scores lower than the same model with no binning. In the hypothetical example above, the model results with no binning scheme achieved a median AUC of ~0.676, while the models with binary or ternary schemes achieved median AUC values of ~0.626 and ~0.652 respectively. This hypothetical example shows that binning schemes can have a negative impact on AUC values in comparison to the untransformed data.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>The findings above show that when reporting model accuracy with AUC, a reader should be wary of any transformation scheme applied to the model output since that scheme can change the AUC value.</p><p>We explored the impact of transformation schemes through the COMPAS dataset provided by ProPublica, demonstrating that when the final output of the model is qualitative scores, in comparison to decile scores or raw scores, the model has lower AUC. We then analyzed a hypothetical example to determine what the general case is when differing binning schemes are applied, inferring that binning schemes with a small number of bins in our hypothetical example can result in lower AUC scores.</p><p>In cases where the output of a model presented to a decision maker is transformed model results, there may be a discrepancy in the accuracy of those presented outputs in comparison to reported accuracy from evaluations. It is important to analyze risk assessments and other models in practice in context of what information is presented to decision makers.</p><h2 id=helpful-resources>Helpful Resources<a hidden class=anchor aria-hidden=true href=#helpful-resources>#</a></h2><ul><li>Tom Augspurger&rsquo;s <a href=https://tomaugspurger.github.io/method-chaining.html>post on method chaining</a> was instrumental in refactoring the data reading steps</li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body><script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>