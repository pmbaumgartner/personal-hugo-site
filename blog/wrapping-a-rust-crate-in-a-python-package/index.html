<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wrapping a Rust Crate in a Python Package | Peter Baumgartner</title><meta name=keywords content><meta name=description content="In this blog post I&rsquo;ll walk through step-by-step how I wrapped the voronoice Rust crate and created a Python package with it. It&rsquo;s written as a development journal, where I walk through my thought process and document the code and errors we&rsquo;re getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.
Motivation Right now I primarily use scipy."><meta name=author content><link rel=canonical href=https://www.peterbaumgartner.com/blog/wrapping-a-rust-crate-in-a-python-package/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-72692144-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Wrapping a Rust Crate in a Python Package"><meta property="og:description" content="In this blog post I&rsquo;ll walk through step-by-step how I wrapped the voronoice Rust crate and created a Python package with it. It&rsquo;s written as a development journal, where I walk through my thought process and document the code and errors we&rsquo;re getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.
Motivation Right now I primarily use scipy."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peterbaumgartner.com/blog/wrapping-a-rust-crate-in-a-python-package/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-01-05T06:43:13-05:00"><meta property="article:modified_time" content="2023-01-05T06:43:13-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wrapping a Rust Crate in a Python Package"><meta name=twitter:description content="In this blog post I&rsquo;ll walk through step-by-step how I wrapped the voronoice Rust crate and created a Python package with it. It&rsquo;s written as a development journal, where I walk through my thought process and document the code and errors we&rsquo;re getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.
Motivation Right now I primarily use scipy."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"Wrapping a Rust Crate in a Python Package","item":"https://www.peterbaumgartner.com/blog/wrapping-a-rust-crate-in-a-python-package/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wrapping a Rust Crate in a Python Package","name":"Wrapping a Rust Crate in a Python Package","description":"In this blog post I\u0026rsquo;ll walk through step-by-step how I wrapped the voronoice Rust crate and created a Python package with it. It\u0026rsquo;s written as a development journal, where I walk through my thought process and document the code and errors we\u0026rsquo;re getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.\nMotivation Right now I primarily use scipy.","keywords":[],"articleBody":" In this blog post I‚Äôll walk through step-by-step how I wrapped the voronoice Rust crate and created a Python package with it. It‚Äôs written as a development journal, where I walk through my thought process and document the code and errors we‚Äôre getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.\nMotivation Right now I primarily use scipy.spatial.Voronoi (which uses Qhull) when making Voronoi diagrams. Here‚Äôs here‚Äôs how I typically use it:\nfrom scipy.spatial import Voronoi v = Voronoi( some_points + [(-1000, -1000), (W + 1000, -1000), (W + 1000, H + 1000), (-1000, H + 1000)], ) verts = v.vertices regions = v.regions regions = [i + i[0:1] for i in regions if len(s) \u003e 0 and -1 not in s] shapes = [verts[i] for i in regions] voronoi_cells = [geo.Polygon(s) for s in shapes] In this API, the vertices attribute returns all the points of the diagram, which are then indexed by regions to get the polygons for each individual cell. I also filter out those that have -1 as an element because it means that they extend infinitely into a certain direction. I am 100% sure I took this code from StackOverflow and barely modified it.\nOne thing I would like is to know the neighbors of each cell. After doing some research, I learned the voronoice Rust crate has a way to access this - as well as provide the other information we also get above. So, let‚Äôs learn how to wrap that crate with PyO3 and make it a python package.\nHere are the questions I have just starting this out:\nShould I replicate the whole API? Or come up with my own data structure that has everything I need? voronoice has a BoundingBox struct. How should I represent that as an input? It uses center, top right, and bottom left as input arguments. I think I‚Äôd prefer (x1, y1, x2, y2), so I can modify that API as well. How do I set up a pipeline to make sure this can be distributed to all available platforms, since it will require compilation? I figure I‚Äôll come up with answers to those questions as I‚Äôm developing, so let‚Äôs get started!\nOf course we need a name, so we‚Äôll just ask ChatGPT‚Ä¶\nAnd voronoiville was born!\nDevelopment I know I‚Äôm going to use pyo3 and maturin. I‚Äôll start with reading the docs for maturin. I use conda and not pyenv, so lets create with a fresh virtual environment, install maturin, and create a new project.\nconda create -n voronoiville python=3.8 pip install maturin maturin new -b pyo3 voronoiville Now I just want to test whether I can call the example function they provide from python. This is our first test of this development loop. I need to compile my rust code, which I do like this:\nmaturin develop Which outputs:\nüì¶ Built wheel for CPython 3.8 to /var/folders/49/l0xcvz7x4hj5_6434zsf6lhc0000gn/T/.tmp3wq1UE/voronoiville-0.1.0-cp38-cp38-macosx_11_0_arm64.whl üõ† Installed voronoiville-0.1.0 Okay so maturin outputs a python wheel to a temporary directory and installs it. Let‚Äôs start up a python REPL and check things out!\n\u003e\u003e\u003e import voronoiville \u003e\u003e\u003e voronoiville.sum_as_string(3, 4) '7' Yay!\nSo we can compile rust and use it in python! That‚Äôs awesome.\nThe main thing we‚Äôll be doing is wrapping another crate, so we need to add that crate as a dependency of our package.\ncargo add voronoice Most of the setup is out of the way now, let‚Äôs write a test function to see if we can return something that‚Äôs converted from rust native types to python types. I‚Äôll just write a dummy function that‚Äôs runs a voronoice documentation example with a slight modification to return some voronoi cell vertices. It looks like this:\n#[pyfunction] fn voronoi() -\u003e Vec\u003c(f64, f64)\u003e { use voronoice::*; // creates a voronoi graph from generated square sites, within a square bounding box of side 5.0 // and runs 4 lloyd relaxation iterations to spread sites in the region let v: Voronoi = VoronoiBuilder::default() .generate_square_sites(10) .set_bounding_box(BoundingBox::new_centered_square(5.0)) .set_lloyd_relaxation_iterations(4) .build() .unwrap(); let vertices = v .vertices() .iter() .map(|v| (v.x, v.y)) .collect::\u003cVec\u003c(f64, f64)\u003e\u003e(); vertices } #[pyfunction] is what‚Äôs doing the magic here. We‚Äôve declared this function returns Vec which PyO3 can automatically convert to python types. Let‚Äôs go back to python and see if we can run this:\n\u003e\u003e\u003e from voronoiville import voronoi \u003e\u003e\u003e voronoi() [(-0.03380489650770409, -0.04864118314550073), ... ] \u003e\u003e\u003e len(voronoi()) 221 Yay! So we have our basic scaffolding for our function, we need to actually make it take some arguments now.\nLet‚Äôs change it so that we can provide our own input points. I tried the code below at first:\nfn voronoi(points: Vec\u003c(f64, f64)\u003e) -\u003e Vec\u003c(f64, f64)\u003e { let sites: Vec\u003cPoint\u003e = points.iter().map(|(x, y)| Point { x, y }).collect(); Alright, our first conundrum! This is giving me:\nerror[E0308]: mismatched types --\u003e src/lib.rs:12:67 | 12 | let sites: Vec = points.iter().map(|(x, y)| Point { x, y }).collect(); | ^ expected `f64`, found `\u0026f64` | help: consider dereferencing the borrow | 12 | let sites: Vec = points.iter().map(|(x, y)| Point { x, y: *y }).collect(); | ++++ Okay so the rust compiler is telling us exactly what we need to do. I thought I could be clever by using the field init shorthand, but alas, I need to dereference the values.\nOnce we fix that issue, by just using the code the compiler provides us, we are able to compile (with maturin develop) and try again!\n\u003e\u003e\u003e from voronoiville import voronoi \u003e\u003e\u003e points = [(0, 0), (0, 1), (1, 0)] \u003e\u003e\u003e voronoi(points) [(-0.05610501383113076, 0.04530452444563185), (-2.5, -2.5), ...] Look at that! It even automatically casted our integer arguments to floats.\nNext I would like to create our own BoundingBox class that can take (x1, y1, x2, y2) as arguments and convert it to the right structure for voronoice.\nIn this case, we already have a thing named BoundingBox imported from voronoi, so we‚Äôll name our struct BoundingBoxPy. The way to expose this as a class in python is with the #[pyclass] annotation. Then, we can change the name of this class when we use it in python, it‚Äôs just called BoundingBox, and not awkwardly BoundingBoxPy.\nThen we need to provide a way to create this object in python. An important note: ‚ÄúBy default it is not possible to create an instance of a custom class from Python code.‚Äù In order to be able to create this in python, we create an impl block for BoundingBoxPy, annotate it with #[pymethods], then annotate this specific method with #[new]. This creates the equivalent of an __init__ method in python. Note that the method name doesn‚Äôt also have to be new, which is typically used for constructors of rust objects - so I‚Äôll call it init to avoid confusion.\n#[pyclass(name = \"BoundingBox\")] struct BoundingBoxPy { x1: f64, y1: f64, x2: f64, y2: f64, } #[pymethods] impl BoundingBoxPy { #[new] fn init(x1: f64, y1: f64, x2: f64, y2: f64) -\u003e Self { BoundingBoxPy { x1, y1, x2, y2 } } } Then we have to add this class to our module. There‚Äôs a block of code in the file that was generated at the bottom we haven‚Äôt explored yet. It currently looks like this (after we add BoundingBoxPy).\n#[pymodule] fn voronoiville(_py: Python, m: \u0026PyModule) -\u003e PyResult\u003c()\u003e { m.add_function(wrap_pyfunction!(sum_as_string, m)?)?; m.add_function(wrap_pyfunction!(voronoi, m)?)?; m.add_class::\u003cBoundingBoxPy\u003e()?; Ok(()) } The line before Ok(()) is where we‚Äôve added our bounding box class. Let‚Äôs test it out in python!\n\u003e\u003e\u003e from voronoiville import BoundingBox \u003e\u003e\u003e BoundingBox(1,2,3,4) \u003cbuiltins.BoundingBox object at 0x1056b12f0\u003e Great, it works (with int -\u003e float casting again!), but we don‚Äôt have a nice representation for it. We can fix that quickly! PyO3 supports the magic methods we‚Äôre used to in python in an impl block annotated with #[pymethods], so our impl block looks like this now:\n#[pymethods] impl BoundingBoxPy { #[new] fn init(x1: f64, y1: f64, x2: f64, y2: f64) -\u003e Self { BoundingBoxPy { x1, y1, x2, y2 } } fn __repr__(\u0026self) -\u003e String { format!( \"BoundingBox({}, {}, {}, {})\", self.x1, self.y1, self.x2, self.y2 ) } fn __str__(\u0026self) -\u003e String { self.__repr__() } } And now‚Ä¶\n\u003e\u003e\u003e from voronoiville import BoundingBox \u003e\u003e\u003e BoundingBox(1,2,3,4) BoundingBox(1, 2, 3, 4) Yay! Alright, now we need to write a trait that converts BoundingBoxPy into voronoice::BoundingBox. The bounding box from voronoice uses a different representation of a rectangle for it‚Äôs constructor, so we‚Äôll have to do some basic math here.\nimpl From\u003cBoundingBoxPy\u003e for BoundingBox { fn from(value: BoundingBoxPy) -\u003e Self { let width = value.x2 - value.x1; let height = value.y2 - value.y1; let center = Point { x: (value.x1 + value.x2) / 2.0, y: (value.y1 + value.y2) / 2.0, }; BoundingBox::new(center, width, height) } } Now we update our function and add the bounding box as an argument. Since we‚Äôve implemented From for BoundingBox, we can add a type annotation for the boundingbox variable and call the into method on BoundingBoxPy:\n#[pyfunction] fn voronoi(points: Vec\u003c(f64, f64)\u003e, bounding_box: BoundingBoxPy) -\u003e Vec\u003c(f64, f64)\u003e { let sites: Vec\u003cPoint\u003e = points.iter().map(|(x, y)| Point { x: *x, y: *y }).collect(); let boundingbox: BoundingBox = bounding_box.into(); let v: Voronoi = VoronoiBuilder::default() .set_sites(sites) .set_bounding_box(boundingbox) .set_lloyd_relaxation_iterations(4) .build() .unwrap(); let vertices = v .vertices() .iter() .map(|v| (v.x, v.y)) .collect::\u003cVec\u003c(f64, f64)\u003e\u003e(); vertices } Let‚Äôs test this out!\nfrom voronoiville import BoundingBox, voronoi points = [(0, 0), (0, 1), (1, 0)] voronoi(points, BoundingBox(-2.5, -2.5, 2.5, 2.5)) [(-0.05610501383113076, 0.04530452444563185), (-2.5, -2.5), (-2.5, 2.5), (2.5, 2.5), (2.5, -2.5), (4435173994.765353, -8962657621.199606), (-9999541625.05059, 95745966.03161913), (4690381324.290731, 8831779154.45233), (1.2475346735079387, 2.5), (1.2034397454112338, -2.5), (-2.5, 0.06870490568260464)] We did it! That makes me think it would be a good idea to create a test to make sure our BoundingBox works correctly. We‚Äôll add this test at the bottom of our main lib.rs file.\n#[cfg(test)] mod tests { use voronoice::BoundingBox; use crate::BoundingBoxPy; #[test] fn bbox_conversion() { let voronoi_bbox = BoundingBox::new_centered_square(5.0); let python_bbox: BoundingBox = BoundingBoxPy::init(-2.5, -2.5, 2.5, 2.5).into(); assert_eq!(voronoi_bbox, python_bbox); } } And we run cargo test and get‚Ä¶\nerror[E0369]: binary operation `==` cannot be applied to type `voronoice::BoundingBox` --\u003e src/lib.rs:86:9 | 86 | assert_eq!(voronoi_bbox, python_bbox); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | | | voronoice::BoundingBox | voronoice::BoundingBox | = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info) For more information about this error, try `rustc --explain E0369`. Okay so I think this is because BoundingBox doesn‚Äôt implement Eq or PartialEq. This means voronoice hasn‚Äôt defined what it means for two bounding boxes to be equal. Which makes sense because when would you ever want to compare two bounding boxes when you‚Äôre just using a single one to construct Voronoi diagrams?\nRather than implement that ourselves, we‚Äôll just check whether some attribute of our two bounding boxes is equal, like .corners(). Changing the assertion to this:\nassert_eq!(voronoi_bbox.corners(), python_bbox.corners()); And then our test passes!\nSome experimentation now. What I really want is a collection of VoronoiCell structs from voronoice, so I can get all the associated data (vertices, points, neighbors). What happens if I just attempt to return Vec? Let‚Äôs just try and change the method signature first to return a this type.\nerror[E0106]: missing lifetime specifier --\u003e src/lib.rs:49:73 | 49 | fn voronoi(points: Vec\u003c(f64, f64)\u003e, bounding_box: BoundingBoxPy) -\u003e Vec { | ^^^^^^^^^^^ expected named lifetime parameter | = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the `'static` lifetime | 49 | fn voronoi(points: Vec\u003c(f64, f64)\u003e, bounding_box: BoundingBoxPy) -\u003e Vec","wordCount":"3686","inLanguage":"en","datePublished":"2023-01-05T06:43:13-05:00","dateModified":"2023-01-05T06:43:13-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/wrapping-a-rust-crate-in-a-python-package/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.peterbaumgartner.com/ title=Home><span>Home</span></a></li><li><a href=https://www.peterbaumgartner.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks><span>Notebooks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Wrapping a Rust Crate in a Python Package</h1><div class=post-meta><span title='2023-01-05 06:43:13 -0500 -0500'>January 5, 2023</span></div></header><div class=post-content><meta property="og:title" content="Wrapping a Rust Crate in a Python Package (Development Journal)"><meta property="og:description" content="A development journal on the process to wrap a rust crate as a python package"><meta property="og:type" content="website"><meta property="og:url" content="https://peterbaumgartner.com/blog/wrapping-a-rust-crate-in-a-python-package/"><meta property="og:image" content="https://i.postimg.cc/NFhNpxK5/crapwrap.jpg"><p>In this blog post I&rsquo;ll walk through step-by-step how I wrapped the <a href=https://docs.rs/voronoice/0.2.0/voronoice/><code>voronoice</code></a> Rust crate and created a Python package with it. It&rsquo;s written as a development journal, where I walk through my thought process and document the code and errors we&rsquo;re getting along the way. My hope is that this makes the process a little more approachable for beginners and adds some transparency to the process.</p><h2 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h2><p>Right now I primarily use <code>scipy.spatial.Voronoi</code> (which uses <a href=http://www.qhull.org/>Qhull</a>) when making Voronoi diagrams. Here&rsquo;s here&rsquo;s how I typically use it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> scipy.spatial <span style=color:#f92672>import</span> Voronoi
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> Voronoi(
</span></span><span style=display:flex><span>    some_points
</span></span><span style=display:flex><span>    <span style=color:#f92672>+</span> [(<span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span>), (W <span style=color:#f92672>+</span> <span style=color:#ae81ff>1000</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span>), (W <span style=color:#f92672>+</span> <span style=color:#ae81ff>1000</span>, H <span style=color:#f92672>+</span> <span style=color:#ae81ff>1000</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span>, H <span style=color:#f92672>+</span> <span style=color:#ae81ff>1000</span>)],
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>verts <span style=color:#f92672>=</span> v<span style=color:#f92672>.</span>vertices
</span></span><span style=display:flex><span>regions <span style=color:#f92672>=</span> v<span style=color:#f92672>.</span>regions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>regions <span style=color:#f92672>=</span> [i <span style=color:#f92672>+</span> i[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> regions <span style=color:#66d9ef>if</span> len(s) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> s]
</span></span><span style=display:flex><span>shapes <span style=color:#f92672>=</span> [verts[i] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> regions]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>voronoi_cells <span style=color:#f92672>=</span> [geo<span style=color:#f92672>.</span>Polygon(s) <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> shapes]
</span></span></code></pre></div><p>In this API, the <code>vertices</code> attribute returns all the points of the diagram, which are then indexed by <code>regions</code> to get the polygons for each individual cell. I also filter out those that have <code>-1</code> as an element because it means that they extend infinitely into a certain direction. I am 100% sure I took this code from StackOverflow and barely modified it.</p><p>One thing I would like is to know the neighbors of each cell. After doing some research, I learned the <code>voronoice</code> Rust crate has a way to access this - as well as provide the other information we also get above. So, let&rsquo;s learn how to wrap that crate with <a href=https://pyo3.rs/>PyO3</a> and make it a python package.</p><p>Here are the questions I have just starting this out:</p><ul><li>Should I replicate the whole API? Or come up with my own data structure that has everything I need?</li><li><code>voronoice</code> has a <code>BoundingBox</code> struct. How should I represent that as an input?<ul><li>It uses center, top right, and bottom left as input arguments. I think I&rsquo;d prefer (x1, y1, x2, y2), so I can modify that API as well.</li></ul></li><li>How do I set up a pipeline to make sure this can be distributed to all available platforms, since it will require compilation?</li></ul><p>I figure I&rsquo;ll come up with answers to those questions as I&rsquo;m developing, so let&rsquo;s get started!</p><p>Of course we need a name, so we&rsquo;ll just ask ChatGPT&mldr;</p><img src=https://i.ibb.co/XjrfgHk/Pasted-image-20221229061141.png alt="Asking ChatGPT what we should name a Voronoi diagram package"><p>And <code>voronoiville</code> was born!</p><h2 id=development>Development<a hidden class=anchor aria-hidden=true href=#development>#</a></h2><p>I know I&rsquo;m going to use <code>pyo3</code> and <code>maturin</code>. I&rsquo;ll start with reading the docs for <a href=https://www.maturin.rs/>maturin</a>. I use <code>conda</code> and not <code>pyenv</code>, so lets create with a fresh virtual environment, install <code>maturin</code>, and create a new project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>conda create -n voronoiville python<span style=color:#f92672>=</span>3.8
</span></span><span style=display:flex><span>pip install maturin
</span></span><span style=display:flex><span>maturin new -b pyo3 voronoiville
</span></span></code></pre></div><p>Now I just want to test whether I can call the example function they provide from python. This is our first test of this development loop. I need to compile my rust code, which I do like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>maturin develop
</span></span></code></pre></div><p>Which outputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>üì¶ Built wheel for CPython 3.8 to /var/folders/49/l0xcvz7x4hj5_6434zsf6lhc0000gn/T/.tmp3wq1UE/voronoiville-0.1.0-cp38-cp38-macosx_11_0_arm64.whl
</span></span><span style=display:flex><span>üõ† Installed voronoiville-0.1.0
</span></span></code></pre></div><p>Okay so <code>maturin</code> outputs a python wheel to a temporary directory and installs it. Let&rsquo;s start up a python REPL and check things out!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> voronoiville
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> voronoiville<span style=color:#f92672>.</span>sum_as_string(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;7&#39;</span>
</span></span></code></pre></div><p>Yay!</p><p>So we can compile rust and use it in python! That&rsquo;s awesome.</p><p>The main thing we&rsquo;ll be doing is wrapping another crate, so we need to add that crate as a dependency of our package.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo add voronoice
</span></span></code></pre></div><p>Most of the setup is out of the way now, let&rsquo;s write a test function to see if we can return something that&rsquo;s converted from rust native types to python types. I&rsquo;ll just write a dummy function that&rsquo;s runs a <code>voronoice</code> documentation example with a slight modification to return some voronoi cell vertices. It looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pyfunction]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>voronoi</span>() -&gt; Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> voronoice::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// creates a voronoi graph from generated square sites, within a square bounding box of side 5.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// and runs 4 lloyd relaxation iterations to spread sites in the region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> v: <span style=color:#a6e22e>Voronoi</span> <span style=color:#f92672>=</span> VoronoiBuilder::default()
</span></span><span style=display:flex><span>        .generate_square_sites(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        .set_bounding_box(BoundingBox::new_centered_square(<span style=color:#ae81ff>5.0</span>))
</span></span><span style=display:flex><span>        .set_lloyd_relaxation_iterations(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vertices <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>        .vertices()
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> (v.x, v.y))
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    vertices
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>#[pyfunction]</code> is what&rsquo;s doing the magic here. We&rsquo;ve declared this function returns <code>Vec&lt;f64, f64></code> which <code>PyO3</code> can automatically convert to python types. Let&rsquo;s go back to python and see if we can run this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> voronoi
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> voronoi()
</span></span><span style=display:flex><span>[(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.03380489650770409</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.04864118314550073</span>), <span style=color:#f92672>...</span> ]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> len(voronoi())
</span></span><span style=display:flex><span><span style=color:#ae81ff>221</span>
</span></span></code></pre></div><p>Yay! So we have our basic scaffolding for our function, we need to actually make it take some arguments now.</p><p>Let&rsquo;s change it so that we can provide our own input points. I tried the code below at first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>voronoi</span>(points: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> sites: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> points.iter().map(<span style=color:#f92672>|</span>(x, y)<span style=color:#f92672>|</span> Point { x, y }).collect();
</span></span></code></pre></div><p>Alright, our first conundrum! This is giving me:</p><pre tabindex=0><code>error[E0308]: mismatched types
  --&gt; src/lib.rs:12:67
   |
12 |     let sites: Vec&lt;Point&gt; = points.iter().map(|(x, y)| Point { x, y }).collect();
   |                                                                   ^ expected `f64`, found `&amp;f64`
   |
help: consider dereferencing the borrow
   |
12 |     let sites: Vec&lt;Point&gt; = points.iter().map(|(x, y)| Point { x, y: *y }).collect();
   |                                                                   ++++
</code></pre><p>Okay so the rust compiler is telling us <em>exactly</em> what we need to do. I thought I could be clever by using the <a href=https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand>field init shorthand</a>, but alas, I need to dereference the values.</p><p>Once we fix that issue, by just using the code the compiler provides us, we are able to compile (with <code>maturin develop</code>) and try again!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> voronoi
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> points <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> voronoi(points)
</span></span><span style=display:flex><span>[(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.05610501383113076</span>, <span style=color:#ae81ff>0.04530452444563185</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>), <span style=color:#f92672>...</span>]
</span></span></code></pre></div><p>Look at that! It even automatically casted our integer arguments to floats.</p><p>Next I would like to create our own <code>BoundingBox</code> class that can take <code>(x1, y1, x2, y2)</code> as arguments and convert it to the right structure for <code>voronoice</code>.</p><p>In this case, we already have a thing named <code>BoundingBox</code> imported from <code>voronoi</code>, so we&rsquo;ll name our struct <code>BoundingBoxPy</code>. The way to expose this as a class in python is with the <code>#[pyclass]</code> <a href=https://doc.rust-lang.org/book/ch19-06-macros.html>annotation</a>. Then, we can change the name of this class when we use it in python, it&rsquo;s just called <code>BoundingBox</code>, and not awkwardly <code>BoundingBoxPy</code>.</p><p>Then we need to provide a way to create this object in python. An <a href=https://pyo3.rs/v0.17.3/class#constructor>important note</a>: &ldquo;By default it is not possible to create an instance of a custom class from Python code.&rdquo; In order to be able to create this in python, we create an <code>impl</code> block for <code>BoundingBoxPy</code>, annotate it with <code>#[pymethods]</code>, then annotate this specific method with <code>#[new]</code>. This creates the equivalent of an <code>__init__</code> method in python. Note that the method name doesn&rsquo;t also have to be <code>new</code>, which is typically used for constructors of rust objects - so I&rsquo;ll call it <code>init</code> to avoid confusion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pyclass(name = </span><span style=color:#e6db74>&#34;BoundingBox&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BoundingBoxPy</span> {
</span></span><span style=display:flex><span>    x1: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>    y1: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>    x2: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>    y2: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[pymethods]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> BoundingBoxPy {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[new]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>init</span>(x1: <span style=color:#66d9ef>f64</span>, y1: <span style=color:#66d9ef>f64</span>, x2: <span style=color:#66d9ef>f64</span>, y2: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        BoundingBoxPy { x1, y1, x2, y2 }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we have to add this class to our module. There&rsquo;s a block of code in the file that was generated at the bottom we haven&rsquo;t explored yet. It currently looks like this (after we add <code>BoundingBoxPy</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pymodule]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>voronoiville</span>(_py: <span style=color:#a6e22e>Python</span>, m: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PyModule</span>) -&gt; <span style=color:#a6e22e>PyResult</span><span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    m.add_function(wrap_pyfunction<span style=color:#f92672>!</span>(sum_as_string, m)<span style=color:#f92672>?</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    m.add_function(wrap_pyfunction<span style=color:#f92672>!</span>(voronoi, m)<span style=color:#f92672>?</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    m.add_class::<span style=color:#f92672>&lt;</span>BoundingBoxPy<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The line before <code>Ok(())</code> is where we&rsquo;ve added our bounding box class. Let&rsquo;s test it out in python!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> BoundingBox
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> BoundingBox(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>builtins<span style=color:#f92672>.</span>BoundingBox object at <span style=color:#ae81ff>0x1056b12f0</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>Great, it works (with <code>int -> float</code> casting again!), but we don&rsquo;t have a nice representation for it. We can fix that quickly! PyO3 supports the magic methods we&rsquo;re used to in python in an <code>impl</code> block annotated with <code>#[pymethods]</code>, so our <code>impl</code> block looks like this now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pymethods]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> BoundingBoxPy {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[new]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>init</span>(x1: <span style=color:#66d9ef>f64</span>, y1: <span style=color:#66d9ef>f64</span>, x2: <span style=color:#66d9ef>f64</span>, y2: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        BoundingBoxPy { x1, y1, x2, y2 }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__repr__</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String {
</span></span><span style=display:flex><span>        format!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;BoundingBox({}, {}, {}, {})&#34;</span>,
</span></span><span style=display:flex><span>            self.x1, self.y1, self.x2, self.y2
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__str__</span>(<span style=color:#f92672>&amp;</span>self) -&gt; String {
</span></span><span style=display:flex><span>        self.__repr__()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> BoundingBox
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> BoundingBox(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>BoundingBox(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)
</span></span></code></pre></div><p>Yay! Alright, now we need to write a trait that converts <code>BoundingBoxPy</code> into <code>voronoice::BoundingBox</code>. The bounding box from <code>voronoice</code> uses a different representation of a rectangle for it&rsquo;s constructor, so we&rsquo;ll have to do some basic math here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>BoundingBoxPy<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> BoundingBox {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(value: <span style=color:#a6e22e>BoundingBoxPy</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> width <span style=color:#f92672>=</span> value.x2 <span style=color:#f92672>-</span> value.x1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> height <span style=color:#f92672>=</span> value.y2 <span style=color:#f92672>-</span> value.y1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> center <span style=color:#f92672>=</span> Point {
</span></span><span style=display:flex><span>            x: (value.x1 <span style=color:#f92672>+</span> value.x2) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>,
</span></span><span style=display:flex><span>            y: (value.y1 <span style=color:#f92672>+</span> value.y2) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        BoundingBox::new(center, width, height)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we update our function and add the bounding box as an argument. Since we&rsquo;ve implemented <code>From</code> for <code>BoundingBox</code>, we can add a type annotation for the <code>boundingbox</code> variable and call the <code>into</code> method on <code>BoundingBoxPy</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pyfunction]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>voronoi</span>(points: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span>, bounding_box: <span style=color:#a6e22e>BoundingBoxPy</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sites: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> points.iter().map(<span style=color:#f92672>|</span>(x, y)<span style=color:#f92672>|</span> Point { x: <span style=color:#f92672>*</span>x, y: <span style=color:#f92672>*</span>y }).collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> boundingbox: <span style=color:#a6e22e>BoundingBox</span> <span style=color:#f92672>=</span> bounding_box.into();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v: <span style=color:#a6e22e>Voronoi</span> <span style=color:#f92672>=</span> VoronoiBuilder::default()
</span></span><span style=display:flex><span>        .set_sites(sites)
</span></span><span style=display:flex><span>        .set_bounding_box(boundingbox)
</span></span><span style=display:flex><span>        .set_lloyd_relaxation_iterations(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> vertices <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>        .vertices()
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> (v.x, v.y))
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    vertices
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s test this out!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> BoundingBox, voronoi
</span></span><span style=display:flex><span>points <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)]
</span></span><span style=display:flex><span>voronoi(points, BoundingBox(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>))
</span></span><span style=display:flex><span>[(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.05610501383113076</span>, <span style=color:#ae81ff>0.04530452444563185</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>), (<span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>), (<span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>), (<span style=color:#ae81ff>4435173994.765353</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>8962657621.199606</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>9999541625.05059</span>, <span style=color:#ae81ff>95745966.03161913</span>), (<span style=color:#ae81ff>4690381324.290731</span>, <span style=color:#ae81ff>8831779154.45233</span>), (<span style=color:#ae81ff>1.2475346735079387</span>, <span style=color:#ae81ff>2.5</span>), (<span style=color:#ae81ff>1.2034397454112338</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>0.06870490568260464</span>)]
</span></span></code></pre></div><p>We did it! That makes me think it would be a good idea to create a test to make sure our BoundingBox works correctly. We&rsquo;ll add this test at the bottom of our main <code>lib.rs</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> voronoice::BoundingBox;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::BoundingBoxPy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bbox_conversion</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> voronoi_bbox <span style=color:#f92672>=</span> BoundingBox::new_centered_square(<span style=color:#ae81ff>5.0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> python_bbox: <span style=color:#a6e22e>BoundingBox</span> <span style=color:#f92672>=</span> BoundingBoxPy::init(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>).into();
</span></span><span style=display:flex><span>        assert_eq!(voronoi_bbox, python_bbox);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we run <code>cargo test</code> and get&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>error[E0369]: binary operation `==` cannot be applied to type `voronoice::BoundingBox`
</span></span><span style=display:flex><span>  --&gt; src/lib.rs:86:9
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>86 |         assert_eq!(voronoi_bbox, python_bbox);
</span></span><span style=display:flex><span>   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style=display:flex><span>   |         |
</span></span><span style=display:flex><span>   |         voronoice::BoundingBox
</span></span><span style=display:flex><span>   |         voronoice::BoundingBox
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For more information about this error, try `rustc --explain E0369`.
</span></span></code></pre></div><p>Okay so I think this is because <code>BoundingBox</code> doesn&rsquo;t implement <code>Eq</code> or <code>PartialEq</code>. This means <code>voronoice</code> hasn&rsquo;t defined what it means for two bounding boxes to be equal. Which makes sense because when would you ever want to compare two bounding boxes when you&rsquo;re just using a single one to construct Voronoi diagrams?</p><p>Rather than implement that ourselves, we&rsquo;ll just check whether some attribute of our two bounding boxes is equal, like <code>.corners()</code>. Changing the assertion to this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>assert_eq!(voronoi_bbox.corners(), python_bbox.corners());
</span></span></code></pre></div><p>And then our test passes!</p><p>Some experimentation now. What I really want is a collection of <code>VoronoiCell</code> <a href=https://docs.rs/voronoice/0.2.0/voronoice/struct.VoronoiCell.html>structs</a> from <code>voronoice</code>, so I can get all the associated data (vertices, points, neighbors). What happens if I just attempt to return <code>Vec&lt;VoronoiCell></code>? Let&rsquo;s just try and change the method signature first to return a this type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>error[E0106]: missing lifetime specifier
</span></span><span style=display:flex><span>  --&gt; src/lib.rs:49:73
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>49 | fn voronoi(points: Vec&lt;(f64, f64)&gt;, bounding_box: BoundingBoxPy) -&gt; Vec&lt;VoronoiCell&gt; {
</span></span><span style=display:flex><span>   |                                                                         ^^^^^^^^^^^ expected named lifetime parameter
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from
</span></span><span style=display:flex><span>help: consider using the `&#39;static` lifetime
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>49 | fn voronoi(points: Vec&lt;(f64, f64)&gt;, bounding_box: BoundingBoxPy) -&gt; Vec&lt;VoronoiCell&lt;&#39;static&gt;&gt; {
</span></span><span style=display:flex><span>   |                                                                                    +++++++++
</span></span></code></pre></div><p>Okay I&rsquo;ll make that change&mldr; then we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>error[E0599]: the method `assert_into_py_result` exists for struct `Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;`, but its trait bounds were not satisfied
</span></span><span style=display:flex><span>   --&gt; src/lib.rs:48:1
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>48  | #[pyfunction]
</span></span><span style=display:flex><span>    | ^^^^^^^^^^^^^ method cannot be called on `Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;` due to unsatisfied trait bounds
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>   ::: /Users/peter/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:400:1
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>400 | pub struct Vec&lt;T, #[unstable(feature = &#34;allocator_api&#34;, issue = &#34;32838&#34;)] A: Allocator = Global&gt; {
</span></span><span style=display:flex><span>    | ------------------------------------------------------------------------------------------------
</span></span><span style=display:flex><span>    | |
</span></span><span style=display:flex><span>    | doesn&#39;t satisfy `Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;: IntoPy&lt;Py&lt;PyAny&gt;&gt;`
</span></span><span style=display:flex><span>    | doesn&#39;t satisfy `_: IntoPyResult&lt;Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;&gt;`
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>    = note: the following trait bounds were not satisfied:
</span></span><span style=display:flex><span>            `Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;: IntoPy&lt;Py&lt;PyAny&gt;&gt;`
</span></span><span style=display:flex><span>            which is required by `Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;: IntoPyResult&lt;Vec&lt;voronoice::VoronoiCell&lt;&#39;_&gt;&gt;&gt;`
</span></span><span style=display:flex><span>            `[voronoice::VoronoiCell&lt;&#39;_&gt;]: Sized`
</span></span><span style=display:flex><span>            which is required by `[voronoice::VoronoiCell&lt;&#39;_&gt;]: IntoPyResult&lt;[voronoice::VoronoiCell&lt;&#39;_&gt;]&gt;`
</span></span><span style=display:flex><span>            `[voronoice::VoronoiCell&lt;&#39;_&gt;]: IntoPy&lt;Py&lt;PyAny&gt;&gt;`
</span></span><span style=display:flex><span>            which is required by `[voronoice::VoronoiCell&lt;&#39;_&gt;]: IntoPyResult&lt;[voronoice::VoronoiCell&lt;&#39;_&gt;]&gt;`
</span></span><span style=display:flex><span>    = note: this error originates in the attribute macro `pyfunction` (in Nightly builds, run with -Z macro-backtrace for more info)
</span></span></code></pre></div><p>Okay so this is actually REALLY AWESOME. The compiler and <a href=https://rust-analyzer.github.io/>rust-analyzer</a> will just tell us when we&rsquo;re returning a thing it doesn&rsquo;t know how to convert back into a python type.</p><p>We could implement <code>IntoPy&lt;Py&lt;PyAny>></code> for <code>VoronoiCell</code>, but I think that would be very painful because it contains a reference back to the <code>Voronoi</code> object that would be built. And that means we&rsquo;d really be implementing something like that for <code>Voronoi</code> eventually.</p><p>I think we&rsquo;ve answered our first question about whether we should recreate the whole <code>voronoice</code> API: no, we should not.</p><p>Let&rsquo;s instead follow the pattern we came up with before and develop a <code>VoronoiCellPy</code> object that we can use instead.</p><p>To do this, I&rsquo;m going to look at what methods are available on the <code>VoronoiCell</code> struct, then convert any data they provide to fields on our new struct.</p><p>Here&rsquo;s my initial sketch of this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pyclass(name = </span><span style=color:#e6db74>&#34;VoronoiCell&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VoronoiCellPy</span> {
</span></span><span style=display:flex><span>    position: (<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>    site: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// These are originally Iterator&lt;Item = &amp;Point&gt;, but we&#39;ll collect + convert to tuples
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vertices: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    neighbors: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    is_on_hull: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>VoronoiCell<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> VoronoiCellPy {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(cell: <span style=color:#a6e22e>VoronoiCell</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> position: (<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>) <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> pos <span style=color:#f92672>=</span> cell.site_position();
</span></span><span style=display:flex><span>            (pos.x, pos.y)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> site: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> cell.site();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> vertices: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> cell
</span></span><span style=display:flex><span>            .iter_vertices()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>point<span style=color:#f92672>|</span> (point.x, point.y))
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> neighbors: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> cell.iter_neighbors().collect();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> is_on_hull <span style=color:#f92672>=</span> cell.is_on_hull();
</span></span><span style=display:flex><span>        VoronoiCellPy {
</span></span><span style=display:flex><span>            position,
</span></span><span style=display:flex><span>            site,
</span></span><span style=display:flex><span>            vertices,
</span></span><span style=display:flex><span>            neighbors,
</span></span><span style=display:flex><span>            is_on_hull,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and now we get&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>error[E0726]: implicit elided lifetime not allowed here
</span></span><span style=display:flex><span>  --&gt; src/lib.rs:52:11
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>52 | impl From&lt;VoronoiCell&gt; for VoronoiCellPy {
</span></span><span style=display:flex><span>   |           ^^^^^^^^^^^ expected lifetime parameter
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   = note: assuming a `&#39;static` lifetime...
</span></span><span style=display:flex><span>help: indicate the anonymous lifetime
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>52 | impl From&lt;VoronoiCell&lt;&#39;_&gt;&gt; for VoronoiCellPy {
</span></span><span style=display:flex><span>   |                      ++++
</span></span></code></pre></div><p>Okay so I made the change that&rsquo;s suggested, but I&rsquo;m not sure why. Luckily the compiler tells me I can learn more by running <code>rustc --explain E0726</code>. So I run that and see if I can figure things out&mldr;</p><p>That leads me to look at the original implementation of <code>VoronoiCell</code>, which looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VoronoiCell</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>v</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    site: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    voronoi: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>v</span> <span style=color:#a6e22e>Voronoi</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What I think this is saying is that since <code>VoronoiCell</code> contains a reference to <code>Voronoi</code>, it&rsquo;s lifetime has to be at least as long as that. Because this is declared for <code>VoronoiCell</code>, I have to be sure that when I&rsquo;m using it to create my <code>VoronoiCellPy</code>, it also knows about that lifetime. I&rsquo;m still a little fuzzy on lifetimes, so I&rsquo;ll write this example down and come back to it once I&rsquo;ve learned a little more to see if I can figure out the details.</p><p>We make that suggested correction and continue on our way.</p><p>I am now getting this nice warning on my <code>VoronoiCellPy</code> struct (which normally I would care about):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>fields `position`, `site`, `vertices`, `neighbors` and `is_on_hull` are never read
</span></span><span style=display:flex><span>`#[warn(dead_code)]` on by default
</span></span></code></pre></div><p>We&rsquo;re not creating any <code>VoronoiCellPy</code> structs yet, but this will go away when we do.</p><p>Let&rsquo;s check if this works in python again!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> voronoiville <span style=color:#f92672>import</span> BoundingBox, voronoi
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> points <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> cells <span style=color:#f92672>=</span> voronoi(points, BoundingBox(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> cells[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>builtins<span style=color:#f92672>.</span>VoronoiCell object at <span style=color:#ae81ff>0x104cee730</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> cells[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>position
</span></span><span style=display:flex><span><span style=color:#a6e22e>AttributeError</span>: <span style=color:#e6db74>&#39;builtins.VoronoiCell&#39;</span> object has no attribute <span style=color:#e6db74>&#39;position&#39;</span>
</span></span></code></pre></div><p>Uh oh. We don&rsquo;t have an attribute <code>position</code>? But I thought we just defined that. Nope! It looks like we need to declare that we can get these attributes as object properties in python using the <a href="https://pyo3.rs/v0.17.3/class.html?highlight=getter#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a> annotation.</p><p>This is actually nice because this is basically a read-only object and we&rsquo;d never want a user to be able to <code>set</code> these attributes, only <code>get</code> them. So our <code>VoronoiCellPy</code> looks like this now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[allow(dead_code)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[pyclass(name = </span><span style=color:#e6db74>&#34;VoronoiCell&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VoronoiCellPy</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[pyo3(get)]</span>
</span></span><span style=display:flex><span>    position: (<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[pyo3(get)]</span>
</span></span><span style=display:flex><span>    site: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// These are originally Iterator&lt;Item = &amp;Point&gt;, but we&#39;ll collect + convert to tuples
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#[pyo3(get)]</span>
</span></span><span style=display:flex><span>    vertices: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[pyo3(get)]</span>
</span></span><span style=display:flex><span>    neighbors: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[pyo3(get)]</span>
</span></span><span style=display:flex><span>    is_on_hull: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we recompile and test in python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># previous commands executed.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> cells <span style=color:#f92672>=</span> voronoi(points, BoundingBox(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>2.5</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> c <span style=color:#f92672>=</span> cells[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> (c<span style=color:#f92672>.</span>position, c<span style=color:#f92672>.</span>site, c<span style=color:#f92672>.</span>vertices, c<span style=color:#f92672>.</span>neighbors, c<span style=color:#f92672>.</span>is_on_hull)
</span></span><span style=display:flex><span>((<span style=color:#f92672>-</span><span style=color:#ae81ff>0.9662767249429629</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.1960951507454378</span>),
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span> [(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.05610501383113076</span>, <span style=color:#ae81ff>0.04530452444563185</span>),
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>1.2034397454112338</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>),
</span></span><span style=display:flex><span>  (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>),
</span></span><span style=display:flex><span>  (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.5</span>, <span style=color:#ae81ff>0.06870490568260464</span>)],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span> <span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><p>We did it! Just for fun, let&rsquo;s try and overwrite <code>c.site</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> c<span style=color:#f92672>.</span>site <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>AttributeError</span>: attribute <span style=color:#e6db74>&#39;site&#39;</span> of <span style=color:#e6db74>&#39;builtins.VoronoiCell&#39;</span> objects <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> writable
</span></span></code></pre></div><p>Perfect.</p><h3 id=adding-default-arguments-and-better-errors>Adding default arguments and better errors<a hidden class=anchor aria-hidden=true href=#adding-default-arguments-and-better-errors>#</a></h3><p>I want to make returning the neighbors is optional, so I added a helper function to create our <code>VoronoiCellPy</code> objects without neighbors. This means the type for the <code>neighbors</code> field is now <code>Option&lt;Vec&lt;usize>></code>.</p><p>I also want to allow a user to determine the number of iterations for the Lloyd relaxation algorithm. However, I want default values for these arguments. The way to do that is to pass them as arguments to the <code>#pyfunction</code> annotation.</p><p>In addition, I also want to provide a better error message when we fail to build a diagram. For example, if a user passes an empty list. The <code>build()</code> method returns an <code>Option&lt;Voronoi></code>, so we&rsquo;ll use <code>ok_or</code> to return/throw the error. We also need to change our function signature to return <code>PyResult&lt;Vec&lt;VoronoiCellPy>></code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[pyfunction(return_neighbors = true, lloyd_relaxation_iterations = 0)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>voronoi</span>(
</span></span><span style=display:flex><span>    points: Vec<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>f64</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    bounding_box: <span style=color:#a6e22e>BoundingBoxPy</span>,
</span></span><span style=display:flex><span>    return_neighbors: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    lloyd_relaxation_iterations: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#a6e22e>PyResult</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>VoronoiCellPy<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sites: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> points.iter().map(<span style=color:#f92672>|</span>(x, y)<span style=color:#f92672>|</span> Point { x: <span style=color:#f92672>*</span>x, y: <span style=color:#f92672>*</span>y }).collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bounding_box: <span style=color:#a6e22e>BoundingBox</span> <span style=color:#f92672>=</span> bounding_box.into();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v: <span style=color:#a6e22e>Voronoi</span> <span style=color:#f92672>=</span> VoronoiBuilder::default()
</span></span><span style=display:flex><span>        .set_sites(sites)
</span></span><span style=display:flex><span>        .set_bounding_box(bounding_box)
</span></span><span style=display:flex><span>        .set_lloyd_relaxation_iterations(lloyd_relaxation_iterations)
</span></span><span style=display:flex><span>        .build()
</span></span><span style=display:flex><span>        .ok_or(PyRuntimeError::new_err(<span style=color:#e6db74>&#34;Can&#39;t build Voronoi diagram from given points.&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cells: Vec<span style=color:#f92672>&lt;</span>VoronoiCellPy<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> return_neighbors {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>true</span> <span style=color:#f92672>=&gt;</span> v.iter_cells().map(<span style=color:#f92672>|</span>cell<span style=color:#f92672>|</span> cell.into()).collect(),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>false</span> <span style=color:#f92672>=&gt;</span> v
</span></span><span style=display:flex><span>            .iter_cells()
</span></span><span style=display:flex><span>            .map(VoronoiCellPy::into_no_neighbors)
</span></span><span style=display:flex><span>            .collect(),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    Ok(cells)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without updating the error message and return type, here&rsquo;s what a user sees if <code>build()</code> fails:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>thread &#39;&lt;unnamed&gt;&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, src/lib.rs:136:22
</span></span><span style=display:flex><span>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></span><span style=display:flex><span>---------------------------------------------------------------------------
</span></span><span style=display:flex><span>PanicException                            Traceback (most recent call last)
</span></span><span style=display:flex><span>Cell In[20], line 1
</span></span><span style=display:flex><span>----&gt; 1 voronoi([], BoundingBox(0, 0, 1,1))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PanicException: called `Option::unwrap()` on a `None` value
</span></span></code></pre></div><p>Yikes! So it&rsquo;s partially informative if you know Rust and what&rsquo;s going on, but not really useful if you&rsquo;re only using python.</p><h3 id=docstrings--type-annotations>Docstrings & Type Annotations<a hidden class=anchor aria-hidden=true href=#docstrings--type-annotations>#</a></h3><p>I think we need some documentation for our library! There&rsquo;s a nice <a href=https://pyo3.rs/v0.17.3/python_typing_hints>page on python typing hints</a> in the PyO3 documentation. Because we have a simple package, all we need to do is add a <code>voronoiville.pyi</code> file to our root directory and add in type stubs there.</p><p>In addition to type stubs, this is also where we can add docstrings. You can also add docstrings in the Rust code, but I find it easier to write them in python so I can use the <a href="https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring">AutoDocstring</a> extension once I add the type hints.</p><h2 id=building--delivery>Building & Delivery<a hidden class=anchor aria-hidden=true href=#building--delivery>#</a></h2><p>This process probably deserves it&rsquo;s own blog post, so I&rsquo;ll keep this section short. Our goal is to have someone be able to call <code>pip install voronoiville</code>. In python, if your package is only python code, you can typically just build a single wheel or sdist and upload that to PyPI. That&rsquo;s not the case here! In our case, we&rsquo;re actually building an <a href=https://llllllllll.github.io/c-extension-tutorial/what-is-an-extension-module.html>extension module</a> which requires a bit more involvement. The <code>PyO3</code> docs have a <a href=https://pyo3.rs/v0.17.3/building_and_distribution#building-python-extension-modules>helpful explanation</a>:</p><blockquote><p>Python extension modules need to be compiled differently depending on the OS (and architecture) that they are being compiled for. As well as multiple OSes (and architectures), there are also many different Python versions which are actively supported. Packages uploaded to <a href=https://pypi.org/>PyPI</a> usually want to upload prebuilt &ldquo;wheels&rdquo; covering many OS/arch/version combinations so that users on all these different platforms don&rsquo;t have to compile the package themselves. Package vendors can opt-in to the &ldquo;abi3&rdquo; limited Python API which allows their wheels to be used on multiple Python versions, reducing the number of wheels they need to compile, but restricts the functionality they can use.</p></blockquote><p>Rather than figure out the details of a build process, I copied and modified the GitHub Action (GHA) that <a href=https://github.com/adriangb/graphlib2><code>graphlib2</code></a> uses to build and release. I found this example because the <a href=https://github.com/PyO3/maturin-action#examples><code>matiurin-action</code> GitHub Action repo</a> has a list of example repositories that use that to build. If you just want to get your package built, I&rsquo;d encourage you to do something similar and copy from an existing open-source repos build process.</p><p>One thing we&rsquo;ll want to do is use the &ldquo;abi3&rdquo; limited Python API mentioned. This will allow us to build a single wheel for all python versions 3.7+. To do this, we have to modify a line in our dependencies in the <code>Cargo.toml</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a6e22e>pyo3</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.17.3&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;extension-module&#34;</span>, <span style=color:#e6db74>&#34;abi3-py37&#34;</span>] }
</span></span></code></pre></div><p>We&rsquo;ve added the <code>abi3-py37</code> feature to our dependencies. A <code>feature</code> is like an <code>extra</code> if you&rsquo;re used to python packages.</p><p>Once our packages are built, we need to upload them to PyPI. The GitHub Action we use references a secret <code>PYPI_TOKEN</code> you can include to upload your package&rsquo;s wheels.</p><p>I added some modifications to the GitHub Action to only build when I modify a relevant source code file (in <code>src</code>) and to only publish to PyPI when I push a tag.</p><p>In short, to avoid build pains, just copy what someone else is doing and modify it to your liking. In that spirit, <a href=https://github.com/pmbaumgartner/voronoiville/blob/72ba0c90332e129d52c6e53e68b5bbc64991d3c2/.github/workflows/ci.yml>here&rsquo;s the build process I&rsquo;m currently using</a>.</p><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>We did it! We wrapped a rust crate and transformed it into a python package. The result is we can build Voronoi diagrams <a href=https://github.com/pmbaumgartner/voronoiville/blob/main/extra/benchmark.ipynb>4-5x faster</a> than our previous method, which is great!</p><p>The Rust development process was painless after we got our tooling setup. In this case, I really felt comfortable relying on the compiler and got this sensation of the <a href="https://www.youtube.com/watch?v=CJtvnepMVAU">compiler teaching me</a>.</p><p>I think the primary obstacle was thinking about <em>what</em> we wanted to return from our function and ensuring it was a struct composed only of native python types. Once we had figured that out, the rest of the development process was straightforward and the quality of the PyO3 API and documentation really made developing a breeze.</p><p>Here&rsquo;s the final result: <a href=https://github.com/pmbaumgartner/voronoiville/>https://github.com/pmbaumgartner/voronoiville/</a></p><p><a href=https://github.com/pmbaumgartner/voronoiville><img loading=lazy src="https://gh-card.dev/repos/pmbaumgartner/voronoiville.svg?fullname=" alt="pmbaumgartner/voronoiville - GitHub"></a></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body><script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>