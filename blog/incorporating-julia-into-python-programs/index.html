<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Incorporating Julia Into Python Programs | Peter Baumgartner</title><meta name=keywords content><meta name=description content="Context: I&rsquo;ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia & PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here&rsquo;s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future."><meta name=author content><link rel=canonical href=https://www.peterbaumgartner.com/blog/incorporating-julia-into-python-programs/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-72692144-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Incorporating Julia Into Python Programs"><meta property="og:description" content="Context: I&rsquo;ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia & PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here&rsquo;s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peterbaumgartner.com/blog/incorporating-julia-into-python-programs/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-08-09T11:35:27-04:00"><meta property="article:modified_time" content="2021-08-09T11:35:27-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Incorporating Julia Into Python Programs"><meta name=twitter:description content="Context: I&rsquo;ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia & PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here&rsquo;s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"Incorporating Julia Into Python Programs","item":"https://www.peterbaumgartner.com/blog/incorporating-julia-into-python-programs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Incorporating Julia Into Python Programs","name":"Incorporating Julia Into Python Programs","description":"Context: I\u0026rsquo;ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia \u0026amp; PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here\u0026rsquo;s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future.","keywords":[],"articleBody":" Context: I’ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia \u0026 PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here’s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future.\nPrelude: Environment Preparation There are a lot of things that can go wrong with virtual environments, Julia installation, and python linking, so I’ve found the easiest way to get things setup is using a Docker image with VSCode’s dev containers.\nA basic Dockerfile that works for us looks like this:\nFROM python:3.8 WORKDIR /app RUN pip install julia jill ipython --no-cache-dir # julia is pyjulia, our python-julia interface # jill is a python package for easy Julia installation # IPython is helpful for magic (both %time and %julia) # Include these in your requirements.txt if you have that instead RUN jill install 1.6.2 --confirm # PyJulia setup (installs PyCall \u0026 other necessities) RUN python -c \"import julia; julia.install()\" # Helpful Development Packages RUN julia -e 'using Pkg; Pkg.add([\"Revise\", \"BenchmarkTools\"])' If you’re using VSCode, you can set up a dev container to use this image as a remote container, which allows you to code inside this environment and save all changes locally. To do this, create a devcontainer/devcontainer.json file at your project root with the following:\n// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at: // https://github.com/microsoft/vscode-dev-containers/tree/v0.187.0/containers/python-3 { \"name\": \"PyJulia Env\", \"build\": { \"dockerfile\": \"../Dockerfile\", \"context\": \"../.\", }, // Set *default* container specific settings.json values on container create. \"settings\": { \"python.pythonPath\": \"/usr/local/bin/python\", \"python.languageServer\": \"Pylance\", \"python.linting.enabled\": true, \"python.linting.pylintEnabled\": true, }, // Add the IDs of extensions you want installed when the container is created. \"extensions\": [ \"ms-python.python\", \"ms-python.vscode-pylance\", \"julialang.language-julia\" ], // We will use this later, leave commented out for now. // \"postStartCommand\": \"julia -e 'import Pkg; Pkg.develop(path=\\\"MyPackage\\\")'\", } The rest of this tutorial assumes you are working in a dev container with the Dockerfile and .devcontainer setup above. Alternatively, if you’re able to get Julia and Python working with whatever setup you have, congrats!\n(Author’s Note: I have macOS 11.5.1 (Big Sur) and typically use conda for environment management and I kept getting a segfault when trying to import PyJulia, hence the docker approach.)\nUsing PyJulia Now lets write some Julia! Open up a python REPL (we’re using IPython, though I’m using the standard \u003e\u003e\u003e to indicate an input) and run the following:\n\u003e\u003e\u003e from julia import Main \u003e\u003e\u003e Main.println(\"I'm printing from a Julia function!\") I'm printing from a Julia function! This will import Julia, start up the Julia interpreter, and print the statement using the Julia println function.\nMain is the global namespace of the Julia interpreter. What does this mean? Anything you’d have available if you started up a Julia REPL can be called with Main.. If you were in a Julia REPL, you’d just type , but if that worked the same way in python we’d have collisions with python functions and not know when we’re using Julia. If you have some frequently used Julia functions, you can rewrite references to functions to be more clear:\n\u003e\u003e\u003e rand_jl = Main.rand \u003e\u003e\u003e rand_jl(3) array([0.74949659, 0.50848869, 0.67415476]) The above example also illustrates the automatic type conversion that’s going to happen when you pass things back and forth between python and Julia. We passed our Julia function a python int, which Julia has a native type for (Int). The return object is a numpy array; a python list in Julia is a Vector or Array, and will always get converted to a numpy array on the return trip.\nTypes are very important in Julia because of multiple dispatch. If you need to know the type of something in Julia after PyJulia converts it, you can call Main.typeof to get the type of the thing. This returns a PyCall.jlwrap object, which is used when there’s no automatic conversion to a python type in the returned object. The output is a Julia DataType, which has no equivalent in Python (this is shown in the last example).\n\u003e\u003e\u003e Main.typeof(3) \u003cPyCall.jlwrap Int64\u003e \u003e\u003e\u003e Main.typeof([1, 2, 3, 4]) \u003cPyCall.jlwrap Vector{Int64}\u003e \u003e\u003e\u003e Main.typeof((1, 2, 3, 4)) \u003cPyCall.jlwrap NTuple{4, Int64}\u003e \u003e\u003e\u003e Main.typeof({\"key\" : \"value\"}) PyCall.jlwrap Dict{Any, Any}\u003e \u003e\u003e\u003e Main.typeof(\"String!\") \u003cPyCall.jlwrap String\u003e # Meta! \u003e\u003e\u003e Main.typeof(Main.typeof(3)) \u003cPyCall.jlwrap DataType\u003e This is really important to understand and is probably the #1 reason why something you think should work in Julia doesn’t. You will need to know the types of the objects and convert them when you see a Julia function you want to use that takes an argument that is not one of these automatically converted types.\nFor example, lets say I want an array of random integers. In Julia I can do this with the rand function by passing it a type and the number of objects of that type I want, e.g. rand(Int, 40). But how do you get the Int object, which is a Type, which doesn’t exist in python, to pass this function?\nRemember you can access any Julia objects in the global namespace with Main, so we can do this like:\n# Our renamed function \u003e\u003e\u003e rand_jl(Main.Int, 4000) array([-6472840723767327579, -781971358995470358, 4369709767867909283, ..., 342925672839826321, -4289054831996301088, 2127432410244721707], dtype=int64) Packages Rather than a distinct tool like pip for package management, Julia includes a Julia package for package management called Pkg. You can also call it using PyJulia. Here we’ll install StatsBase (still inside ipython):\n\u003e\u003e\u003e Main.eval('using Pkg; Pkg.add(\"StatsBase\")') Here you also see the use of Main.eval, which allows you to write and evaluate raw Julia code. Note the single quotes for the whole string (in python) and double quotes inside. This is necessary because unlike python, quote types are not interchangeable in Julia. Since this statement is evaluated by Julia, we have to understand how Julia interprets it: a single quote is used for single characters in Julia, and double quotes for strings. If you try the above with 'StatsBase' in single quotes, you’ll get:\nJuliaError: Exception 'syntax: character literal contains multiple characters' occurred while calling julia code: using Pkg; Pkg.add('StatsBase') Once you have packages installed, you can import those into python with normal import syntax. For example, we have StatsBase installed, so we can do this:\n\u003e\u003e\u003e from julia.StatsBase import sample # imports single functions \u003e\u003e\u003e sample([1, 2, 3, 4, 5]) 3 \u003e\u003e\u003e import StatsBase # imports whole module \u003e\u003e\u003e StatsBase.sample([1, 2, 3, 4, 5]) 1 At this point, your brain might look like this: 🤯. You’ve now got a python API to ✨any Julia package you can install✨.\nPyJulia 201 As mentioned above, the #1 reason things will not work when you think they should is that the inputs are the wrong type. Julia uses a concept called multiple dispatch to determine which method to actually call. This means that there are really several versions of the same function, each version is called a method, and the choice of which method gets used depends on the type(s) of the input.\nAs an example let’s say we wanted to get a weighted sample using sample in StatsBase. You can see all the methods available for a function with a call to methods(). Here’s a truncated output for sample:\n\u003e\u003e\u003e Main.methods(StatsBase.sample) \u003cPyCall.jlwrap # 14 methods for generic function \"sample\": [1] sample(wv::StatsBase.AbstractWeights) in StatsBase at /root/.julia/packages/StatsBase/IiL4F/src/sampling.jl:558 [2] sample(a::AbstractArray) in StatsBase at /root/.julia/packages/StatsBase/IiL4F/src/sampling.jl:432 ... [14] sample(rng::Random.AbstractRNG, a::AbstractArray{T, N} where N, wv::StatsBase.AbstractWeights, dims::Tuple{Vararg{Int64, N}} where N; replace, ordered) where T in StatsBase at /root/.julia/packages/StatsBase/IiL4F/src/sampling.jl:936\u003e In the previous section, the method [2] was actually called when we passed it our array. We can verify this with the which function – which itself takes a function and a tuple of types as its arguments and returns the method that would be called with arguments of those types.\n\u003e\u003e\u003e a = [1, 2, 3, 4, 5] \u003e\u003e\u003e Main.which(sample, (Main.typeof(a),)) \u003cPyCall.jlwrap sample(a::AbstractArray) in StatsBase at /root/.julia/packages/StatsBase/IiL4F/src/sampling.jl:432\u003e Now we have a dilemma: how can we do weighted sampling (i.e. call method [1]) when our type is automatically converted? Let’s try first casting our weighted array to a type that would cause the first method to be called.\nIn this example, we’ll use ProbabilityWeights.\n\u003e\u003e\u003e from julia.StatsBase import sample, ProbabilityWeights \u003e\u003e\u003e wv = ProbabilityWeights([0.1, 0.2, 0.3, 0.3, 0.1]) \u003e\u003e\u003e sample(wv) 0.3 Well, that’s not right! We expect this method to return the index of the sampled value (1 to len(array), and yes, we’ll talk about 1-indexing). It appears as if it’s still calling the wrong method because of the automatic type conversion. We can verify with Main.typeof(wv) as it indicates its a Vector{Float64}, when we want ProbabilityWeights{Float64, Float64, Vector{Float64}}.\nIt’s time to write some Julia code to solve this problem!\n\u003e\u003e\u003e weighted_sample_def = \"\"\" using StatsBase function weighted_sample(weights) wv = ProbabilityWeights(weights) return sample(wv) end \"\"\" \u003e\u003e\u003e Main.eval(weighted_sample_def) \u003e\u003e\u003e Main.weighted_sample([0.1, 0.2, 0.3, 0.3, 0.1]) 4 Here we’ve defined the Julia function as a string, told the Julia interpreter to evaluate that code, which brought that function into the Julia namespace, and then called that function using Julia. The function itself handles the conversion from Vector to ProbabilityWeights prior to calling sample. Note that we had to import StatsBase into our Julia namespace: we only imported it as a python module into our python namespace before. (Authors Note: I’m not sure this is exactly right, I was still a little surprised by having to reimport this in Julia.)\nThis works in a pinch, but if we have lots of Julia code we don’t want to write and manage that as a series of python strings 🤢.\nWriting Julia Code in .jl files Remember way back at the beginning when we created a docker image with Julia and connected to the container using VSCode? That’s really going to come in handy now. We also installed the Julia VSCode extension in that step, so we can have our editor help out in writing Julia code.\nLet’s create a new file called functions.jl. You may have to open up a Julia REPL and install the StatsBase package - or run julia -e 'using Pkg; Pkg.add(\"StatsBase\")' from your shell, for this to work (if you didn’t do this above).\nIn this file, we’re going to write the Julia code for our function.\n# functions.jl using StatsBase function weighted_sample(weights) wv = ProbabilityWeights(weights) return sample(wv) end Great, now we’ve got the Julia code in it’s own file. We can now import it into python for use in our package.\nThis might be good time to restart your python REPL to clear all the state and function names we had defined in there. When you restart it, rerun from julia import Main.\nWe’re now going to use include to “import” our Julia code into our Main Julia namespace in python, then attempt to call our weighted sample function. To do that, run the following:\n\u003e\u003e\u003e from julia import Main \u003e\u003e\u003e Main.include(\"functions.jl\") \u003cPyCall.jlwrap weighted_sample\u003e \u003e\u003e\u003e wv = [0.1, 0.2, 0.3, 0.3, 0.1] \u003e\u003e\u003e Main.weighted_sample(wv) 2 Excellent! We can now write and manage our Julia code in a bit more organized fashion. One thing to note is that if you update any Julia functions in your .jl file, all you have to do is rerun Main.include.\n1-indexing and Broadcasting Let’s sidestep a trivial programming debate and get to the point: Julia is 1-indexed, python is 0-indexed. This means our weighted_sample function is going to return values 1 higher than we would expect in python.\nIf we wanted to look up the weight associated with the index returned from a sample, we’ll see this problem:\n\u003e\u003e\u003e wv = [0.1, 0.2, 0.3, 0.3, 0.1] \u003e\u003e\u003e for _ in range(100): \u003e\u003e\u003e index = Main.weighted_sample(wv) \u003e\u003e\u003e print(wv[index]) 0.1 IndexError: list index out of range This highlights an important issue: it’s a good idea to unit test your functions with very basic assertions. This will expose any small issues like this, which will inevitably arise due to the complexity of shipping objects back and forth between languages.\nTo fix this, we need to update our function to subtract 1 from the return value:\nfunction weighted_sample(weights) wv = ProbabilityWeights(weights) return sample(wv) - 1 end If we have a function that returns multiple index values, we can use broadcasting to apply this subtraction to the whole vector. To broadcast a function (depending on the function), you either prefix it (if it’s an operator) or suffix it (if it’s a function) with a period (.).\nFor example, let’s say we want to implement a function that finds the index of all values in an array greater than some number, like so:\nfunction array_gt(array, value) return findall(\u003e(value), array) .- 1 end Now if we checked this in python, we should get the following (assuming you’ve rerun include()):\n\u003e\u003e\u003e Main.array_gt([5, 4, 3, 2, 1], 2) array([0, 1, 2], dtype=int64) Look at that, broadcasting and avoiding IndexError like a pro.\nHelpful tools for include If we want to include this code in a python codebase, there are a few helpful tools in python’s pathlib to help.\nGetting the parent directory of the currently running file can be helpful, if you know where your Julia code is relative to that file. Or in the REPL, it might be helpful to know the current working directory and import from there. For example:\n\u003e\u003e\u003e from pathlib import Path # File being executed Example \u003e\u003e\u003e file_dir = Path(__file__).parent \u003e\u003e\u003e Main.include(f\"{file_dir}/functions.jl\") \u003cPyCall.jlwrap weighted_sample\u003e # Working Directory Example (for REPL) \u003e\u003e\u003e Main.include(str(Path.cwd() / \"functions.jl\")) \u003cPyCall.jlwrap weighted_sample\u003e Benchmarking \u0026 Timing Ready to get into the nitty-gritty? Let’s go!\nIt’s a good idea to time our Julia functions, especially if they have python equivalents. Let’s do that below. (We’re in an IPython REPL here, and we’re going to re-import our functions)\n\u003e\u003e\u003e Main.include(str(Path.cwd() / \"functions.jl\")) \u003cPyCall.jlwrap weighted_sample\u003e \u003e\u003e\u003e wv = [0.1, 0.2, 0.3, 0.3, 0.1] \u003e\u003e\u003e %time Main.weighted_sample(wv) CPU times: user 14.7 ms, sys: 0 ns, total: 14.7 ms Wall time: 14.5 ms 1 \u003e\u003e\u003e %time Main.weighted_sample(wv) CPU times: user 787 µs, sys: 0 ns, total: 787 µs Wall time: 891 µs 1 Wait, so the first time I use it it takes 14.5ms, and the second time it’s 16x faster and takes 891µs? What?\nIf you’ve ever used numba, you might know what’s going on. The first time we call a function in Julia, it’s compiling it.\nNot only that, but each package that’s imported for the first time also has a loading time cost. See the example below.\n\u003e\u003e\u003e from julia import Main \u003e\u003e\u003e %time Main.eval(\"using StatsBase\") CPU times: user 211 ms, sys: 7.06 ms, total: 218 ms Wall time: 220 ms \u003e\u003e\u003e %time Main.eval(\"using StatsBase\") CPU times: user 270 µs, sys: 35 µs, total: 305 µs Wall time: 322 µs In projects with code that runs for a long time, this isn’t going to matter too much. There are python packages that also take as long, if not longer, to import. But, if you are doing benchmarking at this level, it’s very good to be aware of this fact if you’re doing direct comparisons between Julia and Python equivalents.\nGetting Organized \u0026 Scaling Up: Developing a Julia Package As soon as you have more than a handful of functions, you’ll probably want some additional structure to organize your code. Wouldn’t it be nice to have something like from julia import MyPackage and have all your Julia functions nicely namespaced in python instead of a hodge-podge of include statements and file path shenanigans? (Yes, it would!) Additionally, if you were looking to give this codebase to a colleague to help you develop, one problem is that the environment and project isn’t replicable. We added StatsBase from the REPL, but if we gave our current codebase to a colleague, we’d have to tell them to open a REPL and run the install commands above after they got set up. We could add it to the Dockerfile, since we already have Revise and BenchmarkTools, but those are there solely to ease the development process: they aren’t requirements for executing our Julia code.\nTo facilitate organizing our code, we’re going to create a Julia package. To do that, we’ll load up the Julia REPL and run the following:\njulia\u003e ] (@v1.6) pkg\u003e generate MyPackage Generating project MyPackage: MyPackage/Project.toml MyPackage/src/MyPackage.jl This might seem weird, but, Julia comes with a package management REPL. Up to this point, we’ve been using the functional API in Pkg. This time, we opened a Julia REPL and hit ] which entered the Pkg REPL. If we wanted to use the functional API, we could have done the following as well:\njulia\u003e import Pkg; Pkg.generate(\"MyPackage\") We’ve now got a new directory named for our package, and two generated files for our package within it: a Project.toml which will list the dependencies when we add them, and a src/MyPackage.jl which will house our package code.\nWhile we’re in the package REPL, let’s add our StatsBase dependency. We first have to activate the environment for our package by typing activate MyPackage. Once you do this, you should see the REPL change to indicate the active environment. Then, type add StatsBase to add the dependency.\n(@v1.6) pkg\u003e activate MyPackage Activating environment at `/workspaces/pyjulia-demo/MyPackage/Project.toml` (MyPackage) pkg\u003e add StatsBase Updating registry at `~/.julia/registries/General` [... packages being installed ...] Precompiling project... 1 dependency successfully precompiled in 2 seconds (11 already precompiled) You should see that the Project.toml file now includes a line with StatsBase and a UUID. Great, we’ve successfully declared our dependency.\nNow let’s update our package with our functions. Since we already had our code in a functions.jl file, copy this to the MyPackage/src folder. Then, update the src/MyPackage.jl file to the following:\nmodule MyPackage export weighted_sample include(\"functions.jl\") end # module The one new line here, export weighted_sample, is indicating that we want to export that function as a part of the public API of this module.\n(Authors Note: I had to do this initially, but then I removed the export statement later and things still worked. 🤷)\nFinally, we need to tell our development container that we want to use this package locally in development mode. Back in the .devcontainer/devcontainer.json file, you can uncomment the last line, which looks like this:\n\"postStartCommand\": \"julia -e 'import Pkg; Pkg.develop(path=\\\"MyPackage\\\")'\", This will add the local file path as a package in development mode.\nNow, rebuild your dev container in VSCode. At the end of the rebuild process, you should see a new terminal window that will run the above command, installing our package in development mode.\nTo check that everything is working correctly, open the Julia REPL and try loading our package:\njulia\u003e using MyPackage [ Info: Precompiling MyPackage [e94922da-031a-4938-8ed5-8bef1659fee7] We’re in business!\nSince our objective is to be able to use Julia from python, let’s open up our IPython REPL and also verify that our package works.\n\u003e\u003e\u003e from julia import MyPackage \u003e\u003e\u003e MyPackage.weighted_sample([0.1, 0.2, 0.3, 0.3, 0.1]) 4 Look at that: we can just import the package like a regular python package! No more include scattered throughout.\nContinuing Development You’ll likely want to be able to continue development of your package now that we’ve got things setup. One helpful tool here is the Revise.jl package we installed through the Dockerfile. You can even set this up to work with ipython, similar to the %autoreload magic, so that any change in your Julia package code is reflected in your python environment. Let’s check that out.\nStart up an ipython REPL, and then immediately type these magic commands:\n%config JuliaMagics.revise = True %load_ext julia.magic This will turn on Revise for this REPL session. Let’s load our package and play around.\n\u003e\u003e\u003e from julia import MyPackage \u003e\u003e\u003e MyPackage.weighted_sample([0.1, 0.2, 0.3, 0.3, 0.1]) 1 Nothing new here. Keeping your IPython REPL session open, let’s add a new function to our package, in MyPackage/src/functions.jl:\n# MyPackage/src/functions.jl newfunc() = println(\"A new function, cool!\") Now, back in the REPL, you should be able to call this new function:\n\u003e\u003e\u003e MyPackage.newfunc() A new function, cool! You can also add these commands to your ipython config to automatically do this upon startup.\nWrap Up \u0026 Next Steps You now have a workflow that should allow you to develop a Julia package alongside your python code. As you continue with development, some natural next steps might be:\nFinalize your Julia package: pulling it into it’s own repo, checking it into version control, and publishing it to a remote and optionally a registry. You’ll then need to free your development version and add the remote version. Create a Julia sysimage to speed up the startup time. This will be helpful if you add a lot of dependencies with longer startup times. In addition, PyJulia has a function to do this specifically for the dependencies it installs. Helpful References PyJulia Documentation Rewriting Pieces of a Python Codebase in Julia | Satvik Souza Beri | JuliaCon2021 Stack Overflow: R renv vs Python virtual environments vs Julia environments Pkg.jl Glossary The “Why Didn’t You” Section At several points you might be saying “but Peter, why didn’t you X?” Here’s why:\nWhy didn’t you add the package in development mode through the Dockerfile? In development mode, Julia links to a local package path. Within our Dockerfile during the build process, we’re operating in a different directory than the working directory of the development container once we’re in it. Thus, we need to declare the path to the dev version of the package relative to the source tree we’re working in, not the docker build context.\nWhy didn’t you create a new Julia environment, then declare your local package as a dependency? Coming from python, my mental model of environment and package management is a little different than how Julia’s works. I wanted to get a reader up and running without getting bogged down in Julia’s package/project/environment documentation. My understanding is that a “more correct” way to do this, which would be required once the package is finalized, would be to create a root level project and Project.toml, then declare our finalized version of MyPackage as a dependency. This would also be required if we were developing locally, not inside the dev container. However, getting there within this tutorial means potentially managing nested Project.toml files and possibly confusing the reader… but maybe I’m the only one who is confused.\n","wordCount":"3717","inLanguage":"en","datePublished":"2021-08-09T11:35:27-04:00","dateModified":"2021-08-09T11:35:27-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/incorporating-julia-into-python-programs/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.peterbaumgartner.com/ title=Home><span>Home</span></a></li><li><a href=https://www.peterbaumgartner.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks><span>Notebooks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Incorporating Julia Into Python Programs</h1><div class=post-meta><span title='2021-08-09 11:35:27 -0400 -0400'>August 9, 2021</span></div></header><div class=post-content><meta name=twitter:card content="summary"><meta name=twitter:site content="@pmbaumgartner"><meta name=twitter:creator content="@pmbaumgartner"><meta name=twitter:title content="Incorporating Julia Into Python Programs"><meta name=twitter:description content="A collection of notes on how to get started writing Julia for inclusion in python programs."><meta name=twitter:image content="https://i.ibb.co/vLsQRRr/Frame-9.png"><p><strong>Context:</strong> I&rsquo;ve recently been experimenting with porting portions of a simulation codebase from python to Julia. Setting up a productive development environment, using the packages (PyJulia & PyCall) that allow for communicating between python and Julia, and familiarizing myself with Julia enough to use those packages took quite a bit of time and experimentation. Here&rsquo;s my collection of notes including stumbling blocks, adaptations, and things I took forever to understand to make this process easier for others in the future.</p><h2 id=prelude-environment-preparation>Prelude: Environment Preparation<a hidden class=anchor aria-hidden=true href=#prelude-environment-preparation>#</a></h2><p>There are a lot of things that can go wrong with virtual environments, Julia installation, and python linking, so I&rsquo;ve found the easiest way to get things setup is using a Docker image with VSCode&rsquo;s dev containers.</p><p>A basic <code>Dockerfile</code> that works for us looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.8</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install julia jill ipython --no-cache-dir<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># julia is pyjulia, our python-julia interface</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># jill is a python package for easy Julia installation</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># IPython is helpful for magic (both %time and %julia)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Include these in your requirements.txt if you have that instead</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> jill install 1.6.2 --confirm<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># PyJulia setup (installs PyCall &amp; other necessities)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> python -c <span style=color:#e6db74>&#34;import julia; julia.install()&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Helpful Development Packages</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> julia -e <span style=color:#e6db74>&#39;using Pkg; Pkg.add([&#34;Revise&#34;, &#34;BenchmarkTools&#34;])&#39;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>If you&rsquo;re using VSCode, you can set up a <a href=https://code.visualstudio.com/docs/remote/containers>dev container</a> to use this image as a remote container, which allows you to code inside this environment and save all changes locally. To do this, create a <code>devcontainer/devcontainer.json</code> file at your project root with the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// https://github.com/microsoft/vscode-dev-containers/tree/v0.187.0/containers/python-3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;PyJulia Env&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;build&#34;</span>: {
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;dockerfile&#34;</span>: <span style=color:#e6db74>&#34;../Dockerfile&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;context&#34;</span>: <span style=color:#e6db74>&#34;../.&#34;</span>,
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Set *default* container specific settings.json values on container create.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>&#34;settings&#34;</span>: {
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;python.pythonPath&#34;</span>: <span style=color:#e6db74>&#34;/usr/local/bin/python&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;python.languageServer&#34;</span>: <span style=color:#e6db74>&#34;Pylance&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;python.linting.enabled&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>		<span style=color:#f92672>&#34;python.linting.pylintEnabled&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Add the IDs of extensions you want installed when the container is created.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>&#34;extensions&#34;</span>: [
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;ms-python.python&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;ms-python.vscode-pylance&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;julialang.language-julia&#34;</span>
</span></span><span style=display:flex><span>	],
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We will use this later, leave commented out for now.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// &#34;postStartCommand&#34;: &#34;julia -e &#39;import Pkg; Pkg.develop(path=\&#34;MyPackage\&#34;)&#39;&#34;,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The rest of this tutorial assumes you are working in a dev container with the <code>Dockerfile</code> and <code>.devcontainer</code> setup above. Alternatively, if you&rsquo;re able to get Julia and Python working with whatever setup you have, congrats!</p><p>(<em>Author&rsquo;s Note</em>: I have macOS 11.5.1 (Big Sur) and typically use <code>conda</code> for environment management and I kept getting a segfault when trying to import PyJulia, hence the docker approach.)</p><h2 id=using-pyjulia>Using PyJulia<a hidden class=anchor aria-hidden=true href=#using-pyjulia>#</a></h2><p>Now lets write some Julia! Open up a python REPL (we&rsquo;re using IPython, though I&rsquo;m using the standard <code>>>></code> to indicate an input) and run the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia <span style=color:#f92672>import</span> Main
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>println(<span style=color:#e6db74>&#34;I&#39;m printing from a Julia function!&#34;</span>)
</span></span><span style=display:flex><span>I<span style=color:#e6db74>&#39;m printing from a Julia function!</span>
</span></span></code></pre></div><p>This will import Julia, start up the Julia interpreter, and print the statement using the Julia <code>println</code> function.</p><p><code>Main</code> is the global namespace of the Julia interpreter. What does this mean? Anything you&rsquo;d have available if you started up a Julia REPL can be called with <code>Main.&lt;function></code>. If you were in a Julia REPL, you&rsquo;d just type <code>&lt;function></code>, but if that worked the same way in python we&rsquo;d have collisions with python functions and not know when we&rsquo;re using Julia. If you have some frequently used Julia functions, you can rewrite references to functions to be more clear:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> rand_jl <span style=color:#f92672>=</span> Main<span style=color:#f92672>.</span>rand
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> rand_jl(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>array([<span style=color:#ae81ff>0.74949659</span>, <span style=color:#ae81ff>0.50848869</span>, <span style=color:#ae81ff>0.67415476</span>])
</span></span></code></pre></div><p>The above example also illustrates the automatic type conversion that&rsquo;s going to happen when you pass things back and forth between python and Julia. We passed our Julia function a python <code>int</code>, which Julia has a native type for (<code>Int</code>). The return object is a <code>numpy</code> array; a python <code>list</code> in Julia is a <code>Vector</code> or <code>Array</code>, and will always get converted to a <code>numpy</code> array on the return trip.</p><p>Types are very important in Julia because of multiple dispatch. If you need to know the type of something in Julia after PyJulia converts it, you can call <code>Main.typeof</code> to get the type of the thing. This returns a <code>PyCall.jlwrap</code> object, which is used when there&rsquo;s no automatic conversion to a python type in the returned object. The output is a Julia <code>DataType</code>, which has no equivalent in Python (this is shown in the last example).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap Int64<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof([<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap Vector{Int64}<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof((<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap NTuple{<span style=color:#ae81ff>4</span>, Int64}<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof({<span style=color:#e6db74>&#34;key&#34;</span> : <span style=color:#e6db74>&#34;value&#34;</span>})
</span></span><span style=display:flex><span>PyCall<span style=color:#f92672>.</span>jlwrap Dict{Any, Any}<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof(<span style=color:#e6db74>&#34;String!&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap String<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Meta!</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>typeof(Main<span style=color:#f92672>.</span>typeof(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap DataType<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>This is <strong>really important</strong> to understand and is probably the #1 reason why something you think should work in Julia doesn&rsquo;t. You will need to know the types of the objects and convert them when you see a Julia function you want to use that takes an argument that is <strong>not</strong> one of these automatically converted types.</p><p>For example, lets say I want an array of random integers. In Julia I can do this with the <code>rand</code> function by passing it a type and the number of objects of that type I want, e.g. <code>rand(Int, 40)</code>. But how do you get the <code>Int</code> object, which is a <code>Type</code>, which doesn&rsquo;t exist in python, to pass this function?</p><p>Remember you can access any Julia objects in the global namespace with <code>Main</code>, so we can do this like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Our renamed function</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> rand_jl(Main<span style=color:#f92672>.</span>Int, <span style=color:#ae81ff>4000</span>)
</span></span><span style=display:flex><span>array([<span style=color:#f92672>-</span><span style=color:#ae81ff>6472840723767327579</span>,  <span style=color:#f92672>-</span><span style=color:#ae81ff>781971358995470358</span>,  <span style=color:#ae81ff>4369709767867909283</span>,
</span></span><span style=display:flex><span>       <span style=color:#f92672>...</span>,   <span style=color:#ae81ff>342925672839826321</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>4289054831996301088</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2127432410244721707</span>], dtype<span style=color:#f92672>=</span>int64)
</span></span></code></pre></div><h2 id=packages>Packages<a hidden class=anchor aria-hidden=true href=#packages>#</a></h2><p>Rather than a distinct tool like <code>pip</code> for package management, Julia includes a Julia package for package management called <code>Pkg</code>. You can also call it using PyJulia. Here we&rsquo;ll install <code>StatsBase</code> (still inside ipython):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#39;using Pkg; Pkg.add(&#34;StatsBase&#34;)&#39;</span>)
</span></span></code></pre></div><p>Here you also see the use of <code>Main.eval</code>, which allows you to write and evaluate raw Julia code. <strong>Note the single quotes</strong> for the whole string (in python) and double quotes inside. This is necessary because unlike python, quote types are not interchangeable in Julia. Since this statement is evaluated by Julia, we have to understand how Julia interprets it: a single quote is used for single characters in Julia, and double quotes for strings. If you try the above with <code>'StatsBase'</code> in single quotes, you&rsquo;ll get:</p><pre tabindex=0><code>JuliaError: Exception &#39;syntax: character literal contains multiple characters&#39; occurred while calling julia code:
using Pkg; Pkg.add(&#39;StatsBase&#39;)
</code></pre><p>Once you have packages installed, you can import those into python with normal import syntax. For example, we have <code>StatsBase</code> installed, so we can do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia.StatsBase <span style=color:#f92672>import</span> sample <span style=color:#75715e># imports single functions</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> sample([<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> StatsBase <span style=color:#75715e># imports whole module</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> StatsBase<span style=color:#f92672>.</span>sample([<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>At this point, your brain might look like this: 🤯. You&rsquo;ve now got a python API to ✨<strong>any Julia package you can install</strong>✨.</p><h2 id=pyjulia-201>PyJulia 201<a hidden class=anchor aria-hidden=true href=#pyjulia-201>#</a></h2><p>As mentioned above, the #1 reason things will not work when you think they should is that the inputs are the wrong type. Julia uses a concept called multiple dispatch to determine which method to actually call. This means that there are really <em>several</em> versions of the same <em>function</em>, each version is called a <em>method</em>, and the choice of which method gets used depends on the type(s) of the input.</p><p>As an example let&rsquo;s say we wanted to get a weighted sample using <code>sample</code> in <code>StatsBase</code>. You can see all the methods available for a function with a call to <code>methods(&lt;function>)</code>. Here&rsquo;s a truncated output for <code>sample</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>methods(StatsBase<span style=color:#f92672>.</span>sample) 
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap <span style=color:#75715e># 14 methods for generic function &#34;sample&#34;:</span>
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>] sample(wv::StatsBase<span style=color:#f92672>.</span>AbstractWeights) <span style=color:#f92672>in</span> StatsBase at <span style=color:#f92672>/</span>root<span style=color:#f92672>/.</span>julia<span style=color:#f92672>/</span>packages<span style=color:#f92672>/</span>StatsBase<span style=color:#f92672>/</span>IiL4F<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>sampling<span style=color:#f92672>.</span>jl:<span style=color:#ae81ff>558</span>
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>2</span>] sample(a::AbstractArray) <span style=color:#f92672>in</span> StatsBase at <span style=color:#f92672>/</span>root<span style=color:#f92672>/.</span>julia<span style=color:#f92672>/</span>packages<span style=color:#f92672>/</span>StatsBase<span style=color:#f92672>/</span>IiL4F<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>sampling<span style=color:#f92672>.</span>jl:<span style=color:#ae81ff>432</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>14</span>] sample(rng::Random<span style=color:#f92672>.</span>AbstractRNG, a::AbstractArray{T, N} where N, wv::StatsBase<span style=color:#f92672>.</span>AbstractWeights, dims::Tuple{Vararg{Int64, N}} where N; replace, ordered) where T <span style=color:#f92672>in</span> StatsBase at <span style=color:#f92672>/</span>root<span style=color:#f92672>/.</span>julia<span style=color:#f92672>/</span>packages<span style=color:#f92672>/</span>StatsBase<span style=color:#f92672>/</span>IiL4F<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>sampling<span style=color:#f92672>.</span>jl:<span style=color:#ae81ff>936</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>In the previous section, the method <code>[2]</code> was actually called when we passed it our array. We can verify this with the <code>which</code> function &ndash; which itself takes a function and a tuple of types as its arguments and returns the method that would be called with arguments of those types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>which(sample, (Main<span style=color:#f92672>.</span>typeof(a),))
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap sample(a::AbstractArray) <span style=color:#f92672>in</span> StatsBase at <span style=color:#f92672>/</span>root<span style=color:#f92672>/.</span>julia<span style=color:#f92672>/</span>packages<span style=color:#f92672>/</span>StatsBase<span style=color:#f92672>/</span>IiL4F<span style=color:#f92672>/</span>src<span style=color:#f92672>/</span>sampling<span style=color:#f92672>.</span>jl:<span style=color:#ae81ff>432</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>Now we have a dilemma: how can we do weighted sampling (i.e. call method <code>[1]</code>) when our type is automatically converted? Let&rsquo;s try first casting our weighted array to a type that would cause the first method to be called.</p><p>In this example, we&rsquo;ll use <code>ProbabilityWeights</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia.StatsBase <span style=color:#f92672>import</span> sample, ProbabilityWeights
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> wv <span style=color:#f92672>=</span> ProbabilityWeights([<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> sample(wv)
</span></span><span style=display:flex><span><span style=color:#ae81ff>0.3</span>
</span></span></code></pre></div><p>Well, that&rsquo;s not right! We expect this method to return the index of the sampled value (<code>1 to len(array)</code>, and yes, we&rsquo;ll talk about 1-indexing). It appears as if it&rsquo;s still calling the wrong method because of the automatic type conversion. We can verify with <code>Main.typeof(wv)</code> as it indicates its a <code>Vector{Float64}</code>, when we want <code>ProbabilityWeights{Float64, Float64, Vector{Float64}}</code>.</p><p>It&rsquo;s time to write some Julia code to solve this problem!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> weighted_sample_def <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>using StatsBase
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>function weighted_sample(weights)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    wv = ProbabilityWeights(weights)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    return sample(wv)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>end
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>eval(weighted_sample_def)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>weighted_sample([<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>Here we&rsquo;ve defined the Julia function as a string, told the Julia interpreter to evaluate that code, which brought that function into the Julia namespace, and then called that function using Julia. The function itself handles the conversion from <code>Vector</code> to <code>ProbabilityWeights</code> prior to calling <code>sample</code>. Note that we had to import <code>StatsBase</code> into our Julia namespace: we only imported it as a python module into our python namespace before. (<em>Authors Note</em>: I&rsquo;m not sure this is exactly right, I was still a little surprised by having to reimport this in Julia.)</p><p>This works in a pinch, but if we have lots of Julia code we don&rsquo;t want to write and manage that as a series of python strings 🤢.</p><h2 id=writing-julia-code-in-jl-files>Writing Julia Code in .jl files<a hidden class=anchor aria-hidden=true href=#writing-julia-code-in-jl-files>#</a></h2><p>Remember way back at the beginning when we created a docker image with Julia and connected to the container using VSCode? That&rsquo;s really going to come in handy now. We also installed the Julia VSCode extension in that step, so we can have our editor help out in writing Julia code.</p><p>Let&rsquo;s create a new file called <code>functions.jl</code>. You may have to open up a Julia REPL and install the <code>StatsBase</code> package - or run <code>julia -e 'using Pkg; Pkg.add("StatsBase")'</code> from your shell, for this to work (if you didn&rsquo;t do this above).</p><p>In this file, we&rsquo;re going to write the Julia code for our function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># functions.jl</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> StatsBase
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> weighted_sample(weights)
</span></span><span style=display:flex><span>    wv <span style=color:#f92672>=</span> ProbabilityWeights(weights)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sample(wv)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Great, now we&rsquo;ve got the Julia code in it&rsquo;s own file. We can now import it into python for use in our package.</p><p>This might be good time to restart your python REPL to clear all the state and function names we had defined in there. When you restart it, rerun <code>from julia import Main</code>.</p><p>We&rsquo;re now going to use <code>include</code> to &ldquo;import&rdquo; our Julia code into our Main Julia namespace in python, then attempt to call our weighted sample function. To do that, run the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia <span style=color:#f92672>import</span> Main
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>include(<span style=color:#e6db74>&#34;functions.jl&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap weighted_sample<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> wv <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>weighted_sample(wv)
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Excellent! We can now write and manage our Julia code in a bit more organized fashion. One thing to note is that if you update any Julia functions in your <code>.jl</code> file, all you have to do is rerun <code>Main.include</code>.</p><h3 id=1-indexing-and-broadcasting>1-indexing and Broadcasting<a hidden class=anchor aria-hidden=true href=#1-indexing-and-broadcasting>#</a></h3><p>Let&rsquo;s sidestep a trivial programming debate and get to the point: Julia is 1-indexed, python is 0-indexed. This means our <code>weighted_sample</code> function is going to return values 1 higher than we would expect in python.</p><p>If we wanted to look up the weight associated with the index returned from a sample, we&rsquo;ll see this problem:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> wv <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>     index <span style=color:#f92672>=</span> Main<span style=color:#f92672>.</span>weighted_sample(wv)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span>     print(wv[index])
</span></span><span style=display:flex><span><span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>IndexError</span>: list index out of range
</span></span></code></pre></div><p>This highlights an important issue: <strong>it&rsquo;s a good idea to unit test your functions with very basic assertions.</strong> This will expose any small issues like this, which will inevitably arise due to the complexity of shipping objects back and forth between languages.</p><p>To fix this, we need to update our function to subtract 1 from the return value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> weighted_sample(weights)
</span></span><span style=display:flex><span>    wv <span style=color:#f92672>=</span> ProbabilityWeights(weights)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sample(wv) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>If we have a function that returns multiple index values, we can use broadcasting to apply this subtraction to the whole vector. To broadcast a function (depending on the function), you either prefix it (if it&rsquo;s an operator) or suffix it (if it&rsquo;s a function) with a period (<code>.</code>).</p><p>For example, let&rsquo;s say we want to implement a function that finds the index of all values in an array greater than some number, like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> array_gt(array, value)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> findall(<span style=color:#f92672>&gt;</span>(value), array) <span style=color:#f92672>.-</span> <span style=color:#ae81ff>1</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Now if we checked this in python, we should get the following (assuming you&rsquo;ve rerun <code>include(&lt;yourfile>)</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>array_gt([<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>array([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>], dtype<span style=color:#f92672>=</span>int64)
</span></span></code></pre></div><p>Look at that, broadcasting and avoiding <code>IndexError</code> like a pro.</p><h2 id=helpful-tools-for-include>Helpful tools for <code>include</code><a hidden class=anchor aria-hidden=true href=#helpful-tools-for-include>#</a></h2><p>If we want to include this code in a python codebase, there are a few helpful tools in python&rsquo;s <code>pathlib</code> to help.</p><p>Getting the parent directory of the currently running file can be helpful, if you know where your Julia code is relative to that file. Or in the REPL, it might be helpful to know the current working directory and import from there. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># File being executed Example</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> file_dir <span style=color:#f92672>=</span> Path(__file__)<span style=color:#f92672>.</span>parent
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>include(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>file_dir<span style=color:#e6db74>}</span><span style=color:#e6db74>/functions.jl&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap weighted_sample<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Working Directory Example (for REPL)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>include(str(Path<span style=color:#f92672>.</span>cwd() <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;functions.jl&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap weighted_sample<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h2 id=benchmarking--timing>Benchmarking & Timing<a hidden class=anchor aria-hidden=true href=#benchmarking--timing>#</a></h2><p>Ready to get into the nitty-gritty? Let&rsquo;s go!</p><p>It&rsquo;s a good idea to time our Julia functions, especially if they have python equivalents. Let&rsquo;s do that below. (We&rsquo;re in an IPython REPL here, and we&rsquo;re going to re-import our functions)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> Main<span style=color:#f92672>.</span>include(str(Path<span style=color:#f92672>.</span>cwd() <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;functions.jl&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>PyCall<span style=color:#f92672>.</span>jlwrap weighted_sample<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> wv <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>%</span>time Main<span style=color:#f92672>.</span>weighted_sample(wv)
</span></span><span style=display:flex><span>CPU times: user <span style=color:#ae81ff>14.7</span> ms, sys: <span style=color:#ae81ff>0</span> ns, total: <span style=color:#ae81ff>14.7</span> ms
</span></span><span style=display:flex><span>Wall time: <span style=color:#ae81ff>14.5</span> ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>%</span>time Main<span style=color:#f92672>.</span>weighted_sample(wv)
</span></span><span style=display:flex><span>CPU times: user <span style=color:#ae81ff>787</span> µs, sys: <span style=color:#ae81ff>0</span> ns, total: <span style=color:#ae81ff>787</span> µs
</span></span><span style=display:flex><span>Wall time: <span style=color:#ae81ff>891</span> µs
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Wait, so the first time I use it it takes <code>14.5ms</code>, and the second time it&rsquo;s 16x faster and takes <code>891µs</code>? What?</p><p>If you&rsquo;ve ever used <code>numba</code>, you might know what&rsquo;s going on. The first time we call a function in Julia, it&rsquo;s compiling it.</p><p>Not only that, but each package that&rsquo;s imported for the first time also has a loading time cost. See the example below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia <span style=color:#f92672>import</span> Main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>%</span>time Main<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#34;using StatsBase&#34;</span>)
</span></span><span style=display:flex><span>CPU times: user <span style=color:#ae81ff>211</span> ms, sys: <span style=color:#ae81ff>7.06</span> ms, total: <span style=color:#ae81ff>218</span> ms
</span></span><span style=display:flex><span>Wall time: <span style=color:#ae81ff>220</span> ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>%</span>time Main<span style=color:#f92672>.</span>eval(<span style=color:#e6db74>&#34;using StatsBase&#34;</span>)
</span></span><span style=display:flex><span>CPU times: user <span style=color:#ae81ff>270</span> µs, sys: <span style=color:#ae81ff>35</span> µs, total: <span style=color:#ae81ff>305</span> µs
</span></span><span style=display:flex><span>Wall time: <span style=color:#ae81ff>322</span> µs
</span></span></code></pre></div><p>In projects with code that runs for a long time, this isn&rsquo;t going to matter too much. There are python packages that also take as long, if not longer, to import. But, if you are doing benchmarking at this level, it&rsquo;s very good to be aware of this fact if you&rsquo;re doing direct comparisons between Julia and Python equivalents.</p><h2 id=getting-organized--scaling-up-developing-a-julia-package>Getting Organized & Scaling Up: Developing a Julia Package<a hidden class=anchor aria-hidden=true href=#getting-organized--scaling-up-developing-a-julia-package>#</a></h2><p>As soon as you have more than a handful of functions, you&rsquo;ll probably want some additional structure to organize your code. Wouldn&rsquo;t it be nice to have something like <code>from julia import MyPackage</code> and have all your Julia functions nicely namespaced in python instead of a hodge-podge of include statements and file path shenanigans? (Yes, it would!) Additionally, if you were looking to give this codebase to a colleague to help you develop, one problem is that the environment and project isn&rsquo;t replicable. We added <code>StatsBase</code> from the REPL, but if we gave our current codebase to a colleague, we&rsquo;d have to tell them to open a REPL and run the install commands above after they got set up. We could add it to the <code>Dockerfile</code>, since we already have <code>Revise</code> and <code>BenchmarkTools</code>, but those are there solely to ease the development process: they aren&rsquo;t requirements for executing our Julia code.</p><p>To facilitate organizing our code, we&rsquo;re going to create a Julia package. To do that, we&rsquo;ll load up the Julia REPL and run the following:</p><pre tabindex=0><code>julia&gt; ]
(@v1.6) pkg&gt; generate MyPackage
  Generating  project MyPackage:
    MyPackage/Project.toml
    MyPackage/src/MyPackage.jl
</code></pre><p>This might seem weird, but, Julia comes with a package management REPL. Up to this point, we&rsquo;ve been using the functional API in <code>Pkg</code>. This time, we opened a Julia REPL and hit <code>]</code> which entered the <code>Pkg</code> REPL. If we wanted to use the functional API, we could have done the following as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>julia<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>import</span> Pkg; Pkg<span style=color:#f92672>.</span>generate(<span style=color:#e6db74>&#34;MyPackage&#34;</span>)
</span></span></code></pre></div><p>We&rsquo;ve now got a new directory named for our package, and two generated files for our package within it: a <code>Project.toml</code> which will list the dependencies when we add them, and a <code>src/MyPackage.jl</code> which will house our package code.</p><p>While we&rsquo;re in the package REPL, let&rsquo;s add our <code>StatsBase</code> dependency. We first have to <em>activate</em> the environment for our package by typing <code>activate MyPackage</code>. Once you do this, you should see the REPL change to indicate the active environment. Then, type <code>add StatsBase</code> to add the dependency.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>(<span style=color:#a6e22e>@v1</span><span style=color:#ae81ff>.6</span>) pkg<span style=color:#f92672>&gt;</span> activate MyPackage
</span></span><span style=display:flex><span>  Activating environment at <span style=color:#e6db74>`/workspaces/pyjulia-demo/MyPackage/Project.toml`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(MyPackage) pkg<span style=color:#f92672>&gt;</span> add StatsBase
</span></span><span style=display:flex><span>    Updating registry at <span style=color:#e6db74>`~/.julia/registries/General`</span>
</span></span><span style=display:flex><span>	[<span style=color:#f92672>...</span> packages being installed <span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>Precompiling project<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span> dependency successfully precompiled <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>2</span> seconds (<span style=color:#ae81ff>11</span> already precompiled)
</span></span></code></pre></div><p>You should see that the <code>Project.toml</code> file now includes a line with <code>StatsBase</code> and a UUID. Great, we&rsquo;ve successfully declared our dependency.</p><p>Now let&rsquo;s update our package with our functions. Since we already had our code in a <code>functions.jl</code> file, copy this to the <code>MyPackage/src</code> folder. Then, update the <code>src/MyPackage.jl</code> file to the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>module</span> MyPackage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> weighted_sample
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>include(<span style=color:#e6db74>&#34;functions.jl&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#75715e># module</span>
</span></span></code></pre></div><p>The one new line here, <code>export weighted_sample</code>, is indicating that we want to export that function as a part of the public API of this module.</p><p>(<em>Authors Note:</em> I had to do this initially, but then I removed the <code>export</code> statement later and things still worked. 🤷)</p><p>Finally, we need to tell our development container that we want to use this package locally in development mode. Back in the <code>.devcontainer/devcontainer.json</code> file, you can uncomment the last line, which looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#e6db74>&#34;postStartCommand&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#e6db74>&#34;julia -e &#39;import Pkg; Pkg.develop(path=\&#34;MyPackage\&#34;)&#39;&#34;</span><span style=color:#960050;background-color:#1e0010>,</span>
</span></span></code></pre></div><p>This will add the local file path as a package in development mode.</p><p>Now, rebuild your dev container in VSCode. At the end of the rebuild process, you should see a new terminal window that will run the above command, installing our package in development mode.</p><p>To check that everything is working correctly, open the Julia REPL and try loading our package:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>julia<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> MyPackage
</span></span><span style=display:flex><span>[ Info<span style=color:#f92672>:</span> Precompiling MyPackage [e94922da<span style=color:#f92672>-</span><span style=color:#ae81ff>031</span>a<span style=color:#f92672>-</span><span style=color:#ae81ff>4938</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>ed5<span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>bef1659fee7]
</span></span></code></pre></div><p>We&rsquo;re in business!</p><p>Since our objective is to be able to use Julia from python, let&rsquo;s open up our IPython REPL and also verify that our package works.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia <span style=color:#f92672>import</span> MyPackage
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> MyPackage<span style=color:#f92672>.</span>weighted_sample([<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>Look at that: we can just import the package like a regular python package! No more <code>include</code> scattered throughout.</p><h2 id=continuing-development>Continuing Development<a hidden class=anchor aria-hidden=true href=#continuing-development>#</a></h2><p>You&rsquo;ll likely want to be able to continue development of your package now that we&rsquo;ve got things setup. One helpful tool here is the <code>Revise.jl</code> package we installed through the <code>Dockerfile</code>. You can even set this up to work with ipython, similar to the <code>%autoreload</code> magic, so that any change in your Julia package code is reflected in your python environment. Let&rsquo;s check that out.</p><p>Start up an ipython REPL, and then immediately type these magic commands:</p><pre tabindex=0><code>%config JuliaMagics.revise = True
%load_ext julia.magic
</code></pre><p>This will turn on <code>Revise</code> for this REPL session. Let&rsquo;s load our package and play around.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> julia <span style=color:#f92672>import</span> MyPackage
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> MyPackage<span style=color:#f92672>.</span>weighted_sample([<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.1</span>])
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Nothing new here. Keeping your IPython REPL session open, let&rsquo;s add a new function to our package, in <code>MyPackage/src/functions.jl</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># MyPackage/src/functions.jl</span>
</span></span><span style=display:flex><span>newfunc() <span style=color:#f92672>=</span> println(<span style=color:#e6db74>&#34;A new function, cool!&#34;</span>)
</span></span></code></pre></div><p>Now, back in the REPL, you should be able to call this new function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> MyPackage<span style=color:#f92672>.</span>newfunc()
</span></span><span style=display:flex><span>A new function, cool<span style=color:#960050;background-color:#1e0010>!</span>
</span></span></code></pre></div><p>You can also add these commands to your <a href=https://ipython.org/ipython-doc/3/config/intro.html>ipython config</a> to automatically do this upon startup.</p><h2 id=wrap-up--next-steps>Wrap Up & Next Steps<a hidden class=anchor aria-hidden=true href=#wrap-up--next-steps>#</a></h2><p>You now have a workflow that should allow you to develop a Julia package alongside your python code. As you continue with development, some natural next steps might be:</p><ul><li>Finalize your Julia package: pulling it into it&rsquo;s own repo, checking it into version control, and publishing it to a remote and optionally a registry. You&rsquo;ll then need to <a href=http://pkgdocs.julialang.org/v1/managing-packages/#developing>free</a> your development version and add the remote version.</li><li>Create a Julia <a href=https://julialang.github.io/PackageCompiler.jl/dev/sysimages.html>sysimage</a> to speed up the startup time. This will be helpful if you add a lot of dependencies with longer startup times. In addition, <a href=https://pyjulia.readthedocs.io/en/latest/sysimage.html>PyJulia</a> has a function to do this specifically for the dependencies it installs.</li></ul><h2 id=helpful-references>Helpful References<a hidden class=anchor aria-hidden=true href=#helpful-references>#</a></h2><ul><li><a href=https://pyjulia.readthedocs.io/en/latest/index.html>PyJulia Documentation</a></li><li><a href="https://www.youtube.com/watch?v=EnkfGuH6Qhg">Rewriting Pieces of a Python Codebase in Julia | Satvik Souza Beri | JuliaCon2021</a></li><li>Stack Overflow: <a href=https://stackoverflow.com/a/66047402>R renv vs Python virtual environments vs Julia environments</a></li><li><a href=http://pkgdocs.julialang.org/v1/glossary/>Pkg.jl Glossary</a></li></ul><h2 id=the-why-didnt-you-section>The &ldquo;Why Didn&rsquo;t You&rdquo; Section<a hidden class=anchor aria-hidden=true href=#the-why-didnt-you-section>#</a></h2><p>At several points you might be saying &ldquo;but Peter, why didn&rsquo;t you X?&rdquo; Here&rsquo;s why:</p><ul><li><strong>Why didn&rsquo;t you</strong> add the package in development mode through the Dockerfile?</li></ul><p>In development mode, Julia links to a local package path. Within our <code>Dockerfile</code> during the build process, we&rsquo;re operating in a different directory than the working directory of the development container once we&rsquo;re in it. Thus, we need to declare the path to the dev version of the package relative to the source tree we&rsquo;re working in, not the docker build context.</p><ul><li><strong>Why didn&rsquo;t you</strong> create a new Julia environment, then declare your local package as a dependency?</li></ul><p>Coming from python, my mental model of environment and package management is a little different than how Julia&rsquo;s works. I wanted to get a reader up and running without getting bogged down in Julia&rsquo;s package/project/environment documentation. My understanding is that a &ldquo;more correct&rdquo; way to do this, which would be required once the package is finalized, would be to create a root level project and <code>Project.toml</code>, then declare our finalized version of <code>MyPackage</code> as a dependency. This would also be required if we were developing locally, not inside the dev container. However, getting there within this tutorial means potentially managing nested <code>Project.toml</code> files and possibly confusing the reader&mldr; but maybe I&rsquo;m the only one who is confused.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body><script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>