<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Fastest Way to Load Data Into Your Django Project using PostgreSQL | Peter Baumgartner</title><meta name=keywords content><meta name=description content="tl;dr: Load data up to 77x faster with django-postgres-copy and an in-memory csv. Go to results.
When starting a new Django project often my first step is to create a model and bulk load in some existing data. As I&rsquo;ve learned more about Django and databases, I&rsquo;ve learned a few ways to speed up the data loading process. In this post I&rsquo;ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful Faker library."><meta name=author content><link rel=canonical href=https://www.peterbaumgartner.com/blog/the-fastest-way-to-load-data-django-postgresql/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-72692144-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="The Fastest Way to Load Data Into Your Django Project using PostgreSQL"><meta property="og:description" content="tl;dr: Load data up to 77x faster with django-postgres-copy and an in-memory csv. Go to results.
When starting a new Django project often my first step is to create a model and bulk load in some existing data. As I&rsquo;ve learned more about Django and databases, I&rsquo;ve learned a few ways to speed up the data loading process. In this post I&rsquo;ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful Faker library."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peterbaumgartner.com/blog/the-fastest-way-to-load-data-django-postgresql/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-10-08T05:52:23-04:00"><meta property="article:modified_time" content="2019-10-08T05:52:23-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Fastest Way to Load Data Into Your Django Project using PostgreSQL"><meta name=twitter:description content="tl;dr: Load data up to 77x faster with django-postgres-copy and an in-memory csv. Go to results.
When starting a new Django project often my first step is to create a model and bulk load in some existing data. As I&rsquo;ve learned more about Django and databases, I&rsquo;ve learned a few ways to speed up the data loading process. In this post I&rsquo;ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful Faker library."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"The Fastest Way to Load Data Into Your Django Project using PostgreSQL","item":"https://www.peterbaumgartner.com/blog/the-fastest-way-to-load-data-django-postgresql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Fastest Way to Load Data Into Your Django Project using PostgreSQL","name":"The Fastest Way to Load Data Into Your Django Project using PostgreSQL","description":"tl;dr: Load data up to 77x faster with django-postgres-copy and an in-memory csv. Go to results.\nWhen starting a new Django project often my first step is to create a model and bulk load in some existing data. As I\u0026rsquo;ve learned more about Django and databases, I\u0026rsquo;ve learned a few ways to speed up the data loading process. In this post I\u0026rsquo;ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful Faker library.","keywords":[],"articleBody":" tl;dr: Load data up to 77x faster with django-postgres-copy and an in-memory csv. Go to results.\nWhen starting a new Django project often my first step is to create a model and bulk load in some existing data. As I’ve learned more about Django and databases, I’ve learned a few ways to speed up the data loading process. In this post I’ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful Faker library.\nSetup: Some Fake Data We start with a Django model composed of several different types of data:\nclass Thing(models.Model): char = models.CharField(max_length=100) text = models.TextField() integer = models.IntegerField() float = models.FloatField() boolean = models.BooleanField() Using Faker, we’re going to generate some fake data to populate our database of Things.\nfake = Faker() def fake_thing(): return dict( char=fake.name(), text=fake.text(), integer=fake.pyint(), float=fake.pyfloat(), boolean=fake.pybool(), ) n_things = 100 things = [fake_thing() for _ in range(n_things)] This data generation process is run once at the beginning of the script, so the same data is being inserted by each method for a fair comparison.\nMethod 1: .save() on everything One of the first things I learned in Django is how to save to the database using .save() on an object. With this initial knowledge, I used to save a bunch of things in the database with a loop, like this:\nfor thing in things: t = Thing(**thing) t.save() This way totally works! But it’s slow. The issue here is that Django runs in autocommit mode by default, so it’s completing a transaction every time an object is saved.\nAn analogy might help. If we were going to deposit $100 into the bank, autocommit is like forcing the bank teller to deposit our money dollar by dollar, printing a confirmation receipt after each $1 deposit and doing this 100 times. At a large enough scale, this behavior could be really helpful in preventing issues if thousands of people are making deposits of different amounts all at once. In our case we’re the only user of the bank and we want to make one large deposit, so it’s slowing us down.\nMethod 2: Using a Transaction We want all of the objects to be saved at once, or not at all if there’s an error, which means we want a single database transaction to occur. With Django, our code doesn’t need to change much to use a transaction, we just wrap our same loop in the atomic transaction context manager:\nfrom django.db import transaction with transaction.atomic(): for thing in things: t = Thing(**thing) t.save() Learning how to control transactions is a really powerful tool, so head to the Django docs to learn more.\nWrapping it in a transaction means that if there’s an error in saving any of the things in our list, none of them will be saved to the database.\nBack to the analogy, this is like if we gave the teller instructions to deposit the money dollar by dollar, but only give us a single receipt at the end if the whole transaction succeeds. It’s more efficient, but we still want a single $100 deposit not 100 individual $1 deposits.\nMethod 3: bulk_create Wrapping everything in a single transaction helps, but there’s still more room for improvement. With Django models bulk_create is an efficient way to create a bunch of objects all at once in a single query. To use it with Django, your code will look something like this:\nthing_objects = [] for thing in things: t = Thing(**thing) thing_objects.append(t) Thing.objects.bulk_create(thing_objects) The workflow here is slightly different: you don’t call save on each object, but instead store all the objects you want to create in a list, then pass that list to the bulk_create method on the model manager.\nThere are some caveats to bulk_create to consider. The one I encounter most is that it doesn’t call the save method on your model or use any signals. If you already have an application with existing data, or some complex business logic that uses custom save methods or signals, you probably want to think a little more about how your data will be created.\nAt the Bank of Django, bulk_create is probably the closest metal model to how I imagine a deposit working. We give the teller $100 and the teller adds $100 to our account and gives us a receipt indicating the full amount has been deposited all at once.\nMethod 4: PostgreSQL’s COPY command with django-postgres-copy If you aren’t using a PostgreSQL database, bulk_create is usually the best you can get. If you are using PostgreSQL, it has a COPY command, which is described well in the docs:\nCOPY moves data between PostgreSQL tables and standard file-system files.\nThankfully, some amazing people wrote django-postgres-copy to make using COPY with Django super easy. Using this library requires a bit of setup and some helper functions to get started, but the import speedup is worth it.\nAfter installing, we’ll need to add the CopyManager to our Thing model. This means our model now looks like this:\nfrom postgres_copy import CopyManager class Thing(models.Model): char = models.CharField(max_length=100) text = models.TextField() integer = models.IntegerField() float = models.FloatField() boolean = models.BooleanField() objects = CopyManager() This allows us to use a from_csv model manager method to load data from a csv. But things isn’t a csv a csv, it’s a list of dictionaries. I don’t want to clog up my filesystem with a bunch of csv files just to import, so we’ll write a helper function to create an in-memory csv in order to use this method.\nfrom io import StringIO import pandas as pd def in_memory_csv(data): \"\"\"Creates an in-memory csv. Assumes `data` is a list of dicts with native python types.\"\"\" mem_csv = StringIO() pd.DataFrame(data).to_csv(mem_csv, index=False) mem_csv.seek(0) return mem_csv The project I was using already had pandas as a dependency, so I used it for ease. If you’re thinking that using pandas to write a csv is overkill, it’s also easy to write to a csv using the built-in csv module.\nNow that we have this helper function to create an in-memory csv of our things, let’s write the code to insert this data into the database.\nfrom contextlib import closing mem_csv = in_memory_csv(things) with closing(mem_csv) as csv_io: Thing.objects.from_csv(csv_io) Here we used the closing context manager that closes our in-memory csv when we’re done with it. If we don’t close the object and call this multiple times, we’ll run out of memory.\nThis speedup does come at a cost, we’re skipping some validation (database constraints, indexing) that’s happening behind the scenes when we use save or bulk_create. The docs for django-postgres-copy describe options that you can turn on and off when you import.\nOur bank analogy breaks down a bit here, but I’ll give it a shot. Using COPY in this way is like avoiding the teller altogether and telling your bank: “I am depositing $100. Here’s a copy of what my account will look like after I deposit my money. Make it look like this.”\nPerformance Comparison How much faster is using COPY via django-postgres-copy? Anywhere from 34-77x faster than save(), and 3.4-5.8x faster than bulk_create().\nDetailed results are below.\nTHINGS: 1000 Method 01: 0.88s. Speedup: 1.00 Method 02: 0.56s. Speedup: 1.56 Method 03: 0.09s. Speedup: 10.03 Method 04: 0.03s. Speedup: 34.51 THINGS: 10000 Method 01: 8.56s. Speedup: 1.00 Method 02: 5.32s. Speedup: 1.61 Method 03: 0.66s. Speedup: 13.07 Method 04: 0.15s. Speedup: 58.11 THINGS: 50000 Method 01: 42.88s. Speedup: 1.00 Method 02: 27.09s. Speedup: 1.58 Method 03: 3.48s. Speedup: 12.31 Method 04: 0.65s. Speedup: 65.91 THINGS: 100000 Method 01: 97.13s. Speedup: 1.00 Method 02: 61.38s. Speedup: 1.58 Method 03: 7.21s. Speedup: 13.48 Method 04: 1.26s. Speedup: 77.15 THINGS: 500000 Method 01: 490.28s. Speedup: 1.00 Method 02: 293.63s. Speedup: 1.67 Method 03: 46.82s. Speedup: 10.47 Method 04: 8.03s. Speedup: 61.03 Testing Info This was tested locally on my 2018 MacBook Pro using docker with the postgres:11.4 image for the database and the following requirements.txt for the Django app:\nDjango==2.2.5 django-postgres-copy==2.4.2 Faker==2.0.2 pandas==0.25.1 A gist of the management command used for the comparison can be found here.\n","wordCount":"1362","inLanguage":"en","datePublished":"2019-10-08T05:52:23-04:00","dateModified":"2019-10-08T05:52:23-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/the-fastest-way-to-load-data-django-postgresql/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.peterbaumgartner.com/ title=Home><span>Home</span></a></li><li><a href=https://www.peterbaumgartner.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks><span>Notebooks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The Fastest Way to Load Data Into Your Django Project using PostgreSQL</h1><div class=post-meta><span title='2019-10-08 05:52:23 -0400 -0400'>October 8, 2019</span></div></header><div class=post-content><meta name=twitter:card content="summary"><meta name=twitter:site content="@pmbaumgartner"><meta name=twitter:creator content="@pmbaumgartner"><meta name=twitter:title content="The Fastest Way to Load Data Into Your Django Project using PostgreSQL"><meta name=twitter:description content="5.8x faster than bulk_create(), 77x faster than save()"><meta name=twitter:image content="https://avatars1.githubusercontent.com/u/5107405?s=460&v=4"><p><strong>tl;dr</strong>: Load data up to 77x faster with <a href=https://django-postgres-copy.readthedocs.io/en/latest/>django-postgres-copy</a> and an in-memory csv. <a href=#performance-comparison>Go to results</a>.</p><p>When starting a new Django project often my first step is to create a model and bulk load in some existing data. As I&rsquo;ve learned more about Django and databases, I&rsquo;ve learned a few ways to speed up the data loading process. In this post I&rsquo;ll walk through progressively more efficient ways of loading data, and at the end of the post measure the performance of the methods using fake data generated by the wonderful <a href=https://faker.readthedocs.io/en/master/index.html#>Faker</a> library.</p><h2 id=setup-some-fake-data>Setup: Some Fake Data<a hidden class=anchor aria-hidden=true href=#setup-some-fake-data>#</a></h2><p>We start with a Django model composed of several different types of data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thing</span>(models<span style=color:#f92672>.</span>Model):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    char <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    text <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>TextField()
</span></span><span style=display:flex><span>    integer <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>IntegerField()
</span></span><span style=display:flex><span>    float <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>FloatField()
</span></span><span style=display:flex><span>    boolean <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>BooleanField()
</span></span></code></pre></div><p>Using <code>Faker</code>, we&rsquo;re going to generate some fake data to populate our database of Things.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fake <span style=color:#f92672>=</span> Faker()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fake_thing</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dict(
</span></span><span style=display:flex><span>        char<span style=color:#f92672>=</span>fake<span style=color:#f92672>.</span>name(),
</span></span><span style=display:flex><span>        text<span style=color:#f92672>=</span>fake<span style=color:#f92672>.</span>text(),
</span></span><span style=display:flex><span>        integer<span style=color:#f92672>=</span>fake<span style=color:#f92672>.</span>pyint(),
</span></span><span style=display:flex><span>        float<span style=color:#f92672>=</span>fake<span style=color:#f92672>.</span>pyfloat(),
</span></span><span style=display:flex><span>        boolean<span style=color:#f92672>=</span>fake<span style=color:#f92672>.</span>pybool(),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>n_things <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>things <span style=color:#f92672>=</span> [fake_thing() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n_things)]
</span></span></code></pre></div><p>This data generation process is run once at the beginning of the script, so the same data is being inserted by each method for a fair comparison.</p><h2 id=method-1-save-on-everything>Method 1: <code>.save()</code> on everything<a hidden class=anchor aria-hidden=true href=#method-1-save-on-everything>#</a></h2><p>One of the first things I learned in Django is how to save to the database using <code>.save()</code> on an object. With this initial knowledge, I used to save a bunch of things in the database with a loop, like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> thing <span style=color:#f92672>in</span> things:
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> Thing(<span style=color:#f92672>**</span>thing)
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>save()
</span></span></code></pre></div><p>This way totally works! But it&rsquo;s slow. The issue here is that Django runs in autocommit mode by default, so it&rsquo;s completing a transaction every time an object is saved.</p><p>An analogy might help. If we were going to deposit $100 into the bank, autocommit is like forcing the bank teller to deposit our money dollar by dollar, printing a confirmation receipt after each $1 deposit and doing this 100 times. At a large enough scale, this behavior could be really helpful in preventing issues if thousands of people are making deposits of different amounts all at once. In our case we&rsquo;re the only user of the bank and we want to make one large deposit, so it&rsquo;s slowing us down.</p><h2 id=method-2-using-a-transaction>Method 2: Using a Transaction<a hidden class=anchor aria-hidden=true href=#method-2-using-a-transaction>#</a></h2><p>We want all of the objects to be saved at once, or not at all if there&rsquo;s an error, which means we want a single database transaction to occur. With Django, our code doesn&rsquo;t need to change much to use a transaction, we just wrap our same loop in the atomic transaction context manager:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.db <span style=color:#f92672>import</span> transaction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> transaction<span style=color:#f92672>.</span>atomic():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> thing <span style=color:#f92672>in</span> things:
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> Thing(<span style=color:#f92672>**</span>thing)
</span></span><span style=display:flex><span>        t<span style=color:#f92672>.</span>save()
</span></span></code></pre></div><p>Learning how to control transactions is a really powerful tool, so head to the <a href=https://docs.djangoproject.com/en/2.2/topics/db/transactions/#controlling-transactions-explicitly>Django docs</a> to learn more.</p><p>Wrapping it in a transaction means that if there&rsquo;s an error in saving any of the things in our list, none of them will be saved to the database.</p><p>Back to the analogy, this is like if we gave the teller instructions to deposit the money dollar by dollar, but only give us a single receipt at the end if the whole transaction succeeds. It&rsquo;s more efficient, but we still want a single $100 deposit not 100 individual $1 deposits.</p><h2 id=method-3-bulk_create>Method 3: <code>bulk_create</code><a hidden class=anchor aria-hidden=true href=#method-3-bulk_create>#</a></h2><p>Wrapping everything in a single transaction helps, but there&rsquo;s still more room for improvement. With Django models <code>bulk_create</code> is an efficient way to create a bunch of objects all at once in a single query. To use it with Django, your code will look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>thing_objects <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> thing <span style=color:#f92672>in</span> things:
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> Thing(<span style=color:#f92672>**</span>thing)
</span></span><span style=display:flex><span>    thing_objects<span style=color:#f92672>.</span>append(t)
</span></span><span style=display:flex><span>Thing<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>bulk_create(thing_objects)
</span></span></code></pre></div><p>The workflow here is slightly different: you don&rsquo;t call save on each object, but instead store all the objects you want to create in a list, then pass that list to the <code>bulk_create</code> method on the model manager.</p><p>There are some <a href=https://docs.djangoproject.com/en/2.2/ref/models/querysets/#bulk-create>caveats</a> to <code>bulk_create</code> to consider. The one I encounter most is that it doesn&rsquo;t call the save method on your model or use any signals. If you already have an application with existing data, or some complex business logic that uses custom <code>save</code> methods or signals, you probably want to think a little more about how your data will be created.</p><p>At the Bank of Django, <code>bulk_create</code> is probably the closest metal model to how I imagine a deposit working. We give the teller $100 and the teller adds $100 to our account and gives us a receipt indicating the full amount has been deposited all at once.</p><h2 id=method-4-postgresqls-copy-command-with-django-postgres-copy>Method 4: PostgreSQL’s COPY command with <code>django-postgres-copy</code><a hidden class=anchor aria-hidden=true href=#method-4-postgresqls-copy-command-with-django-postgres-copy>#</a></h2><p>If you aren&rsquo;t using a PostgreSQL database, <code>bulk_create</code> is usually the best you can get. If you are using PostgreSQL, it has a <code>COPY</code> command, which is described well in the <a href=https://www.postgresql.org/docs/11/sql-copy.html>docs</a>:</p><blockquote><p><code>COPY</code> moves data between PostgreSQL tables and standard file-system files.</p></blockquote><p>Thankfully, some amazing people wrote <code>django-postgres-copy</code> to make using <code>COPY</code> with Django super easy. Using this library requires a bit of setup and some helper functions to get started, but the import speedup is worth it.</p><p>After installing, we&rsquo;ll need to add the <code>CopyManager</code> to our <code>Thing</code> model. This means our model now looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> postgres_copy <span style=color:#f92672>import</span> CopyManager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thing</span>(models<span style=color:#f92672>.</span>Model):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    char <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    text <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>TextField()
</span></span><span style=display:flex><span>    integer <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>IntegerField()
</span></span><span style=display:flex><span>    float <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>FloatField()
</span></span><span style=display:flex><span>    boolean <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>BooleanField()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    objects <span style=color:#f92672>=</span> CopyManager()
</span></span></code></pre></div><p>This allows us to use a <code>from_csv</code> model manager method to load data from a csv. But <code>things</code> isn&rsquo;t a csv a csv, it&rsquo;s a list of dictionaries. I don&rsquo;t want to clog up my filesystem with a bunch of csv files just to import, so we&rsquo;ll write a helper function to create an in-memory csv in order to use this method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> io <span style=color:#f92672>import</span> StringIO
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>in_memory_csv</span>(data):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Creates an in-memory csv.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Assumes `data` is a list of dicts
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    with native python types.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mem_csv <span style=color:#f92672>=</span> StringIO()
</span></span><span style=display:flex><span>    pd<span style=color:#f92672>.</span>DataFrame(data)<span style=color:#f92672>.</span>to_csv(mem_csv, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    mem_csv<span style=color:#f92672>.</span>seek(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mem_csv
</span></span></code></pre></div><p>The project I was using already had <code>pandas</code> as a dependency, so I used it for ease. If you&rsquo;re thinking that using pandas to write a csv is overkill, it&rsquo;s also easy to write to a csv using the built-in <a href=https://docs.python.org/3/library/csv.html>csv module</a>.</p><p>Now that we have this helper function to create an in-memory csv of our things, let&rsquo;s write the code to insert this data into the database.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> contextlib <span style=color:#f92672>import</span> closing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mem_csv <span style=color:#f92672>=</span> in_memory_csv(things)
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> closing(mem_csv) <span style=color:#66d9ef>as</span> csv_io:
</span></span><span style=display:flex><span>    Thing<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>from_csv(csv_io)
</span></span></code></pre></div><p>Here we used the <a href=https://docs.python.org/3/library/contextlib.html#contextlib.closing>closing context manager</a> that closes our in-memory csv when we&rsquo;re done with it. If we don&rsquo;t close the object and call this multiple times, we&rsquo;ll run out of memory.</p><p>This speedup does come at a cost, we&rsquo;re skipping some validation (database constraints, indexing) that&rsquo;s happening behind the scenes when we use <code>save</code> or <code>bulk_create</code>. The <a href=http://django-postgres-copy.californiacivicdata.org/en/latest/#import-options>docs</a> for <code>django-postgres-copy</code> describe options that you can turn on and off when you import.</p><p>Our bank analogy breaks down a bit here, but I&rsquo;ll give it a shot. Using <code>COPY</code> in this way is like avoiding the teller altogether and telling your bank: &ldquo;I am depositing $100. Here&rsquo;s a <em>copy</em> of what my account will look like after I deposit my money. Make it look like this.&rdquo;</p><h2 id=performance-comparison>Performance Comparison<a hidden class=anchor aria-hidden=true href=#performance-comparison>#</a></h2><p>How much faster is using <code>COPY</code> via <code>django-postgres-copy</code>? <strong>Anywhere from 34-77x faster</strong> than <code>save()</code>, and <strong>3.4-5.8x faster</strong> than <code>bulk_create()</code>.</p><p>Detailed results are below.</p><pre tabindex=0><code>THINGS: 1000
Method 01: 0.88s. Speedup: 1.00
Method 02: 0.56s. Speedup: 1.56
Method 03: 0.09s. Speedup: 10.03
Method 04: 0.03s. Speedup: 34.51
</code></pre><pre tabindex=0><code>THINGS: 10000
Method 01: 8.56s. Speedup: 1.00
Method 02: 5.32s. Speedup: 1.61
Method 03: 0.66s. Speedup: 13.07
Method 04: 0.15s. Speedup: 58.11
</code></pre><pre tabindex=0><code>THINGS: 50000
Method 01: 42.88s. Speedup: 1.00
Method 02: 27.09s. Speedup: 1.58
Method 03: 3.48s. Speedup: 12.31
Method 04: 0.65s. Speedup: 65.91
</code></pre><pre tabindex=0><code>THINGS: 100000
Method 01: 97.13s. Speedup: 1.00
Method 02: 61.38s. Speedup: 1.58
Method 03: 7.21s. Speedup: 13.48
Method 04: 1.26s. Speedup: 77.15
</code></pre><pre tabindex=0><code>THINGS: 500000
Method 01: 490.28s. Speedup: 1.00
Method 02: 293.63s. Speedup: 1.67
Method 03: 46.82s. Speedup: 10.47
Method 04: 8.03s. Speedup: 61.03
</code></pre><h2 id=testing-info>Testing Info<a hidden class=anchor aria-hidden=true href=#testing-info>#</a></h2><p>This was tested locally on my 2018 MacBook Pro using docker with the <code>postgres:11.4</code> image for the database and the following <code>requirements.txt</code> for the Django app:</p><pre tabindex=0><code>Django==2.2.5
django-postgres-copy==2.4.2
Faker==2.0.2
pandas==0.25.1
</code></pre><p>A gist of the management command used for the comparison can be found <a href=https://gist.github.com/pmbaumgartner/17ea7e236c11df1c8a680fe547a312d7>here</a>.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body><script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script></html>