<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>An Introduction to Just Enough Cython to be Useful | Peter Baumgartner</title>
<meta name=keywords content>
<meta name=description content="Since starting work at Explosion, I&rsquo;ve been trying to learn more about Cython. About 16% of spaCy&rsquo;s codebase is Cython, so I decided to pick up a book and learn from that. I did a few example projects and started thinking: now that types are cool in python, why don&rsquo;t more people use Cython?
In case you&rsquo;re unfamiliar with Cython, here&rsquo;s my incremental and oversimplified explanation of what Cython can do:">
<meta name=author content>
<link rel=canonical href=https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.peterbaumgartner.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.peterbaumgartner.com/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.peterbaumgartner.com/favicon-32x32.png>
<link rel=apple-touch-icon href=https://www.peterbaumgartner.com/apple-touch-icon.png>
<link rel=mask-icon href=https://www.peterbaumgartner.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-72692144-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="An Introduction to Just Enough Cython to be Useful">
<meta property="og:description" content="Since starting work at Explosion, I&rsquo;ve been trying to learn more about Cython. About 16% of spaCy&rsquo;s codebase is Cython, so I decided to pick up a book and learn from that. I did a few example projects and started thinking: now that types are cool in python, why don&rsquo;t more people use Cython?
In case you&rsquo;re unfamiliar with Cython, here&rsquo;s my incremental and oversimplified explanation of what Cython can do:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/"><meta property="article:section" content="blog">
<meta property="article:published_time" content="2022-02-28T19:58:19-05:00">
<meta property="article:modified_time" content="2022-02-28T19:58:19-05:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="An Introduction to Just Enough Cython to be Useful">
<meta name=twitter:description content="Since starting work at Explosion, I&rsquo;ve been trying to learn more about Cython. About 16% of spaCy&rsquo;s codebase is Cython, so I decided to pick up a book and learn from that. I did a few example projects and started thinking: now that types are cool in python, why don&rsquo;t more people use Cython?
In case you&rsquo;re unfamiliar with Cython, here&rsquo;s my incremental and oversimplified explanation of what Cython can do:">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://www.peterbaumgartner.com/blog/"},{"@type":"ListItem","position":2,"name":"An Introduction to Just Enough Cython to be Useful","item":"https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"An Introduction to Just Enough Cython to be Useful","name":"An Introduction to Just Enough Cython to be Useful","description":"Since starting work at Explosion, I\u0026rsquo;ve been trying to learn more about Cython. About 16% of spaCy\u0026rsquo;s codebase is Cython, so I decided to pick up a book and learn from that. I did a few example projects and started thinking: now that types are cool in python, why don\u0026rsquo;t more people use Cython?\nIn case you\u0026rsquo;re unfamiliar with Cython, here\u0026rsquo;s my incremental and oversimplified explanation of what Cython can do:","keywords":[],"articleBody":"Since starting work at Explosion, I’ve been trying to learn more about Cython. About 16% of spaCy’s codebase is Cython, so I decided to pick up a book and learn from that. I did a few example projects and started thinking: now that types are cool in python, why don’t more people use Cython?\nIn case you’re unfamiliar with Cython, here’s my incremental and oversimplified explanation of what Cython can do:\n If you’re willing to add a compilation step, you can get a 2-3x speedup on your existing python code. If you’re willing to do (1), and type the variables and functions used in your code, you can get a 10x speedup. If you’re willing to do (1) and (2), and spend some time thinking about your code and some computer science ideas, you can get a significant (50x or more) speedup.  In this blog post I’ll walk you through all three of these incremental approaches in solving a problem using Cython. The problem we’re going to solve is the first problem from Advent of Code 2021. The problem is to take a list of integers (depths) and count the number of times each value in the list is higher than the previous value. Here’s the code for my initial solution:\n# solution.py  from typing import List def count_increases(depths: List[int]) - int: current_depth = depths[0] increase_counter: int = 0 for depth in depths[1:]: if depth  current_depth: increase_counter += 1 current_depth = depth return increase_counter Getting Started There are a few routes to getting started with Cython. The main difference in a workflow that uses Cython is that a compilation step is now required.12 I’ll assume you have are working through an IDE with typical python files.\nTo get started, we’ll need to do three things:\n Install cython (pip install cython) Create a copy of your python code with a .pyx extension. For this example, lets say our source file is solution.py, we’ll create solution.pyx.  If you want to benchmark, rename the pyx file to something distinct like solution_cy.pyx, so you can import it specifically.   Define the compilation step in a setup.py Run the compilation step  Step 3 requires some detail. I added a build step through a setup.py file, which looks like this:\n# setup.py from distutils.core import setup from Cython.Build import cythonize setup( ext_modules=cythonize( \"solution.pyx\", compiler_directives={\"language_level\": \"3\"} ) ) Once you have this file, you will actally run the compile step with the following command:\npython setup.py build_ext --inplace This will create a shared object file (.so) on the python search path. Now, in another python script or REPL, we can do import solution and call solution.count_increases(input_depths).\nTo review, all we’ve done is taking existing python code, changed the file extension, and compiled the code. What did we get from it? In local benchmarks,3 the pure python version took 1.37s and the compiled version took 0.61s, a 2.22x speedup.\nTo recap: we got a 2x speedup by compiling our existing python code with cython.\nTyping with C Types Next, we’ll type our function with C types. For a overview of available types, check the Cython documentation.\nFirst I’ll show the code, then walk through what has changed.\n# solution.pyx cpdef int count_increases_cy(list depths): cdef int increase_counter, current_depth, depth current_depth = depths[0] increase_counter = 0 for depth in depths[1:]: if depth  current_depth: increase_counter += 1 current_depth = depth return increase_counter First is the the cpdef keyword to define the function. This essentially creates a C function, with python syntax, and also creates a python wrapper for that function. If we just used cdef for the fuction, we would define a C function but it wouldn’t be callable from python. Defining functions with cdef is helpful if you had smaller functions that were used inside of any cpdef functions that could operate soley on C types, and you knew they would not need to be called from python.\nAfter cpdef you’ll see the the int type, which in Cython syntax declares the return type of the function. One thing you’ll notice is that the types are in a different order than they are if you’re used to typing things for mypy in python. This also applies to the function arguments, which take their type before their name—in this case we’re declaring depths as a list, but the keyword comes before the name, not after.\nThe first line of the function declares the variables and their types of all the variables we’ll use within the function. If we had multiple variables of different types, we would have several lines that look like this.4 One thing to note here is that we also declare the type of the variable used within the for loop (depth). Since the input type of depths is only a list, we don’t know the types of its contents within the function—we only know it’s a collection of python objects.\nThe remainder of the function is the same, so in total we’ve added a single line that types our object and changed the function signature to match Cython’s syntax. As a result of these changes, this function (once compiled) runs in 0.122s, a 11.3x speedup.\nProfiling and Exploring Python Calls in Cython Code Those two lines of code updates took me a few hours to figure out as a first-time Cython user, especially the part about typing the variable in the for-loop.5 One thing that helped me is Cython’s annotate feature. When you compile your code, you can add annotate=True to the cythonize call, and it will output a helpful HTML report, highlighting in yellow anywhere your code interacts with python, aka the slow parts.\nYou can also click and expand any lines in the report to see the underlying C code. Here’s an example, without typing the depth variable with the for-loop line expanded and the C-code annotated.\n Click image to view full size. I promise this is worth reading along with the next section.\nIn order to progress to the next stage of optimization, we need to spend some time reviewing this output. I’ve broken the C code into 6 chunks. Chunks 1-3 align with the for-loop, and 4-6 align with the comparison of depth  current_depth. Remember that this is the code that did not type depth, the for-loop variable yet.\n For python built-in types passed as arguments, Cython automatically checks if they’re None. There’s currently no way to disable this, but I’m not sure if it’s a big deal.6 A series of variables are created that will allow us to iterate through the loop, e.g. counter variables. The actual loop. This is surpsingly readable if you break it apart and ignore the reference counting. First it checks if the iteration counter (__pyx_t_4) is larger than the size of the list, and if it is, stop looping. Then we’re getting the python object from the sequence (as a slice), storing it as __pyx_t_1, and increasing the iteration counter. Now we’re doing the depth  current_depth comparison. First, it’s converting current_depth, which is typed as a C int, to a python int. This is the first cause of the slowdown, since we didn’t type depth with a C type, we have to convert current_depth back to python to make the comparison. It’s calling PyObject_RichCompare to compare the two python objects, and storing the result of this function as __pyx_t_5. Remember, we know that they’re two integers, but C does not. Finally, it’s calling __Pyx_PyObject_IsTrue on __pyx_t_5. Remember, at this point this is still a python object so it’s evaluating whether than python object is True (not the C type).  Now that we’ve done that review, we know there are two primary parts of our code that make python calls and are slow. We have a python list that we don’t know the length of and can contain any type of object, and in this example we did not type depth, so we have to infer it’s type and convert current_depth—a C int—back to a python int to make the comparison.\nThe Final Optimization: Numpy Arrays \u0026 Memoryviews Arrays in numpy have the exact features to address our slowdowns: they’re of a fixed size and every element is the same type. They’re also easy to work with in Cython. Specifically, if we use numpy arrays we can use something called a memoryview, which is just a view into the array, so it doesn’t require us create a copy of the array and allows for really quick indexing.\nIn order to use numpy with Cython, we need to update our compilation script in setup.py to the following:\n# setup.py from distutils.core import setup from Cython.Build import cythonize import numpy setup( ext_modules=cythonize( \"solution_a_cy.pyx\", compiler_directives={\"language_level\": \"3\"}, annotate=True ), include_dirs=[numpy.get_include()], ) We’ll update our code as follows:\n# solution.pyx cpdef int count_increases_cy_array(int[:] depths): cdef int increase_counter, current_depth, depth, length, i length = depths.shape[0] current_depth = depths[0] increase_counter = 0 for i in range(1, length): if depths[i]  current_depth: increase_counter += 1 current_depth = depths[i] return increase_counter The first difference is that the type of the argument passed to our function is int[:], which is the syntax for a memoryview of an array. This might be a little confusing because we’re going to actually pass a numpy array as the argument7, not a memoryview, but it works regardless. Next, we have some additional variables to create. The two new variables, length and i, allow us to loop through the array and read the value in the array at each index. It’s slightly more verbose than depending on the basic for loop, but is required if we’re going to use an array in this way.\nLet’s take a look at the C code generated from this function. I’ve expanded the two lines we expanded in the previous image: the for-loop and comparison.\n\nThis is much more readable and it tracks very closely with what we have in the python code. More importantly there are no more calls to python within our loop code. It’s doing exactly the simple operation we expect it to: making a comparison between two C ints.\nFor the final speedup comparison, this version of the function runs in 0.157s, an 86x speedup compared to the pure-python version.\nWrap Up: Tempering Expectations Optimizing code like this is always a thrilling adventure, but it leads back to my original question: why isn’t more stuff written with Cython?\nI’d like to point out that not all production code is a simple for loop, conditional logic, and a counter. We have a very simple, isolated problem that lent itself well to illustrating the advantages of Cython. Additionally, it certainly takes some time and energy to come up with these improvements. Sure, you can get a 2x speedup by compiling your normal python code, but the real value is in an 86x speedup on commonly used code.\nLet me summarize and rephrase by quoting from the Cython book I’m reading, from which I shamelessly stole the “Tempering Expectations” section name:\n When improving Python’s performance is the goal, the Pareto principle works in our favor: we can expect that approximately 80 percent of a program’s runtime is due to only 20 percent of the code. A corollary to this principle is that the 20 percent is very difficult to locate without profiling.\np. 7\n The fact is: only 16% of spaCy is written in Cython and the rest is python. While that 16% is code that’s called very often and a core part of the library, for most everything else using and maintaining python code is much easier to manage. With that python code, we get all the additional features of python plus the rest of the ecosystem. Plus we don’t have to consider whether every new feature or component is optimized in Cython or compile a larger part of the library when developing.\nIn summary, Cython is really cool but I’ll only be thinking about using it when:\n I have profiled my code and identified parts of the code that are slow. Those parts of the code use mostly python built-in types or numpy arrays. Those parts of the code are simple so I wouldn’t have to spend much time thinking about how to Cython-ize it. Those parts of the code aren’t going to be under frequent future development.    If you’re into interactive computing, via ipython or jupyter notebooks, there is a %%cython magic you can use. ↩︎\n There is also pyximport, which is included with Cython. However, I couldn’t get it working in the way I wanted it, so it’s not included in this blog post. ↩︎\n I have a M1 MBP. For benchmarking, I used the min value of timeit with 5 repeats of 20000 executions. ↩︎\n There’s also an alternative block syntax for declaring multiple variables. ↩︎\n This is the most critical typing required in the function for a speedup. Without this type, we have to infer the type of the object each iteration. If you exclude this typing (but keep all the others), the speedup is back to the compiled python code version at ~2.2x ↩︎\n https://github.com/cython/cython/issues/3797 ↩︎\n Don’t forget to add the conversion of the input to a numpy array to your execution script. ↩︎\n   ","wordCount":"2190","inLanguage":"en","datePublished":"2022-02-28T19:58:19-05:00","dateModified":"2022-02-28T19:58:19-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/"},"publisher":{"@type":"Organization","name":"Peter Baumgartner","logo":{"@type":"ImageObject","url":"https://www.peterbaumgartner.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.peterbaumgartner.com/ accesskey=h title="Peter Baumgartner (Alt + H)">Peter Baumgartner</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.peterbaumgartner.com/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://www.peterbaumgartner.com/blog/ title=Blog>
<span>Blog</span>
</a>
</li>
<li>
<a href=https://www.peterbaumgartner.com/notebooks/ title=Notebooks>
<span>Notebooks</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
An Introduction to Just Enough Cython to be Useful
</h1>
<div class=post-meta><span title="2022-02-28 19:58:19 -0500 -0500">February 28, 2022</span>
</div>
</header>
<div class=post-content><meta name=twitter:card content="summary">
<meta name=twitter:site content="@pmbaumgartner">
<meta name=twitter:creator content="@pmbaumgartner">
<meta name=twitter:title content="An Introduction to Just Enough Cython to be Useful">
<meta name=twitter:description content="or Why Don't More People Use Cython?">
<meta name=twitter:image content="https://i.ibb.co/LYz2DyQ/1537215809678.jpg">
<p>Since starting work at <a href=https://www.peterbaumgartner.com/blog/personal-history-and-api-design/>Explosion</a>, I&rsquo;ve been trying to learn more about Cython. About 16% of spaCy&rsquo;s codebase is Cython, so I decided to pick up <a href="https://www.amazon.com/dp/B00SNS9JFI/ref=dp_kinw_strp_1">a book</a> and learn from that. I did a few example projects and started thinking: now that types are <em>cool</em> in python, why don&rsquo;t more people use Cython?</p>
<p>In case you&rsquo;re unfamiliar with Cython, here&rsquo;s my incremental and oversimplified explanation of what Cython can do:</p>
<ol>
<li>If you&rsquo;re willing to add a compilation step, you can get a 2-3x speedup on your existing python code.</li>
<li>If you&rsquo;re willing to do (1), and type the variables and functions used in your code, you can get a 10x speedup.</li>
<li>If you&rsquo;re willing to do (1) and (2), and spend some time thinking about your code and some computer science ideas, you can get a significant (50x or more) speedup.</li>
</ol>
<p>In this blog post I&rsquo;ll walk you through all three of these incremental approaches in solving a problem using Cython. The problem we&rsquo;re going to solve is the first problem from <a href=https://adventofcode.com/2021/day/1>Advent of Code 2021</a>. The problem is to take a list of integers (<code>depths</code>) and count the number of times each value in the list is higher than the previous value. Here&rsquo;s the code for my initial solution:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># solution.py </span>
<span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_increases</span>(depths: List[int]) <span style=color:#f92672>-&gt;</span> int:
    current_depth <span style=color:#f92672>=</span> depths[<span style=color:#ae81ff>0</span>]
    increase_counter: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>in</span> depths[<span style=color:#ae81ff>1</span>:]:
        <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>&gt;</span> current_depth:
            increase_counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
        current_depth <span style=color:#f92672>=</span> depth
    <span style=color:#66d9ef>return</span> increase_counter
</code></pre></div><h2 id=getting-started>Getting Started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2>
<p>There are a few routes to getting started with Cython. The main difference in a workflow that uses Cython is that a compilation step is now required.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> I&rsquo;ll assume you have are working through an IDE with typical python files.</p>
<p>To get started, we&rsquo;ll need to do three things:</p>
<ol>
<li>Install cython (<code>pip install cython</code>)</li>
<li>Create a copy of your python code with a <code>.pyx</code> extension. For this example, lets say our source file is <code>solution.py</code>, we&rsquo;ll create <code>solution.pyx</code>.
<ul>
<li>If you want to benchmark, rename the pyx file to something distinct like <code>solution_cy.pyx</code>, so you can import it specifically.</li>
</ul>
</li>
<li>Define the compilation step in a <code>setup.py</code></li>
<li>Run the compilation step</li>
</ol>
<p>Step 3 requires some detail. I added a build step through a <code>setup.py</code> file, which looks like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># setup.py</span>

<span style=color:#f92672>from</span> distutils.core <span style=color:#f92672>import</span> setup
<span style=color:#f92672>from</span> Cython.Build <span style=color:#f92672>import</span> cythonize

setup(
    ext_modules<span style=color:#f92672>=</span>cythonize(
        <span style=color:#e6db74>&#34;solution.pyx&#34;</span>, compiler_directives<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;language_level&#34;</span>: <span style=color:#e6db74>&#34;3&#34;</span>}
    )
)
</code></pre></div><p>Once you have this file, you will actally run the compile step with the following command:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>python setup.py build_ext --inplace
</code></pre></div><p>This will create a shared object file (<code>.so</code>) on the python search path. Now, in another python script or REPL, we can do <code>import solution</code> and call <code>solution.count_increases(input_depths)</code>.</p>
<p>To review, all we&rsquo;ve done is taking existing python code, changed the file extension, and compiled the code. What did we get from it? In local benchmarks,<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> the pure python version took <code>1.37s</code> and the compiled version took <code>0.61s</code>, a <code>2.22x</code> speedup.</p>
<p>To recap: we got a 2x speedup by compiling our existing python code with cython.</p>
<h2 id=typing-with-c-types>Typing with C Types<a hidden class=anchor aria-hidden=true href=#typing-with-c-types>#</a></h2>
<p>Next, we&rsquo;ll type our function with C types. For a overview of available types, check the <a href=https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#types>Cython documentation</a>.</p>
<p>First I&rsquo;ll show the code, then walk through what has changed.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cython data-lang=cython><span style=color:#75715e># solution.pyx</span>

<span style=color:#66d9ef>cpdef</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count_increases_cy</span>(list depths):
    <span style=color:#66d9ef>cdef</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>increase_counter</span>, <span style=color:#a6e22e>current_depth</span>, <span style=color:#a6e22e>depth</span>
    current_depth <span style=color:#f92672>=</span> depths[<span style=color:#ae81ff>0</span>]
    increase_counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>in</span> depths[<span style=color:#ae81ff>1</span>:]:
        <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>&gt;</span> current_depth:
            increase_counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
        current_depth <span style=color:#f92672>=</span> depth
    <span style=color:#66d9ef>return</span> increase_counter
</code></pre></div><p>First is the the <code>cpdef</code> keyword to define the function. This essentially creates a C function, with python syntax, and also creates a python wrapper for that function. If we just used <code>cdef</code> for the fuction, we would define a C function but it wouldn&rsquo;t be callable from python. Defining functions with <code>cdef</code> is helpful if you had smaller functions that were used inside of any <code>cpdef</code> functions that could operate soley on C types, and you knew they would not need to be called from python.</p>
<p>After <code>cpdef</code> you&rsquo;ll see the the <code>int</code> type, which in Cython syntax declares the return type of the function. One thing you&rsquo;ll notice is that the types are in a different order than they are if you&rsquo;re used to typing things for <code>mypy</code> in python. This also applies to the function arguments, which take their type before their name—in this case we&rsquo;re declaring <code>depths</code> as a <code>list</code>, but the keyword comes before the name, not after.</p>
<p>The first line of the function declares the variables and their types of all the variables we&rsquo;ll use within the function. If we had multiple variables of different types, we would have several lines that look like this.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> One thing to note here is that we also declare the type of the variable used within the for loop (<code>depth</code>). Since the input type of <code>depths</code> is only a <code>list</code>, we don&rsquo;t know the types of its contents within the function—we only know it&rsquo;s a collection of python objects.</p>
<p>The remainder of the function is the same, so in total we&rsquo;ve added a single line that types our object and changed the function signature to match Cython&rsquo;s syntax. As a result of these changes, this function (once compiled) runs in <code>0.122s</code>, a <code>11.3x</code> speedup.</p>
<h2 id=profiling-and-exploring-python-calls-in-cython-code>Profiling and Exploring Python Calls in Cython Code<a hidden class=anchor aria-hidden=true href=#profiling-and-exploring-python-calls-in-cython-code>#</a></h2>
<p>Those two lines of code updates took me a few hours to figure out as a first-time Cython user, especially the part about typing the variable in the for-loop.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> One thing that helped me is Cython&rsquo;s <code>annotate</code> feature. When you compile your code, you can add <code>annotate=True</code> to the <code>cythonize</code> call, and it will output a helpful HTML report, highlighting in yellow anywhere your code interacts with python, aka <em>the slow parts</em>.</p>
<p>You can also click and expand any lines in the report to see the underlying C code. Here&rsquo;s an example, <strong>without typing the <code>depth</code> variable</strong> with the for-loop line expanded and the C-code annotated.</p>
<p><a href=cython-annotate-1.png><img loading=lazy src=cython-annotate-1.png alt="Annotated Cython Code">
</a>
<small>Click image to view full size. I promise this is worth reading along with the next section.</small></p>
<p>In order to progress to the next stage of optimization, we need to spend some time reviewing this output. I&rsquo;ve broken the C code into 6 chunks. Chunks 1-3 align with the for-loop, and 4-6 align with the comparison of <code>depth > current_depth</code>. Remember that this is the code that <strong>did not type <code>depth</code>, the for-loop variable</strong> yet.</p>
<ol>
<li>For python built-in types passed as arguments, Cython automatically checks if they&rsquo;re <code>None</code>. There&rsquo;s currently no way to disable this, but I&rsquo;m not sure if it&rsquo;s a big deal.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></li>
<li>A series of variables are created that will allow us to iterate through the loop, e.g. counter variables.</li>
<li>The actual loop. This is surpsingly readable if you break it apart and ignore the reference counting. First it checks if the iteration counter (<code>__pyx_t_4</code>) is larger than the size of the list, and if it is, stop looping. Then we&rsquo;re getting the python object from the sequence (as a slice), storing it as <code>__pyx_t_1</code>, and increasing the iteration counter.</li>
<li>Now we&rsquo;re doing the <code>depth > current_depth</code> comparison. First, it&rsquo;s converting <code>current_depth</code>, which is typed as a C <code>int</code>, to a python <code>int</code>. This is the first cause of the slowdown, since we didn&rsquo;t type <code>depth</code> with a C type, we have to convert <code>current_depth</code> back to python to make the comparison.</li>
<li>It&rsquo;s calling <a href="https://docs.python.org/3/c-api/object.html?highlight=pyobject%20rich%20compare#c.PyObject_RichCompare"><code>PyObject_RichCompare</code></a> to compare the two python objects, and storing the result of this function as <code>__pyx_t_5</code>. Remember, <em>we</em> know that they&rsquo;re two integers, but C does not.</li>
<li>Finally, it&rsquo;s calling <code>__Pyx_PyObject_IsTrue</code> on <code>__pyx_t_5</code>. Remember, at this point this is still a python object so it&rsquo;s evaluating whether than python object is <code>True</code> (not the C type).</li>
</ol>
<p>Now that we&rsquo;ve done that review, we know there are two primary parts of our code that make python calls and are slow. We have a python list that we don&rsquo;t know the length of and can contain any type of object, and in this example we did not type <code>depth</code>, so we have to infer it&rsquo;s type and convert <code>current_depth</code>—a C <code>int</code>—back to a python <code>int</code> to make the comparison.</p>
<h2 id=the-final-optimization-numpy-arrays--memoryviews>The Final Optimization: Numpy Arrays & Memoryviews<a hidden class=anchor aria-hidden=true href=#the-final-optimization-numpy-arrays--memoryviews>#</a></h2>
<p>Arrays in <code>numpy</code> have the exact features to address our slowdowns: they&rsquo;re of a fixed size and every element is the same type. They&rsquo;re also <a href=https://cython.readthedocs.io/en/latest/src/userguide/numpy_tutorial.html#numpy-tutorial>easy to work with in Cython</a>. Specifically, if we use <code>numpy</code> arrays we can use something called a <code>memoryview</code>, which is just a view into the array, so it doesn&rsquo;t require us create a copy of the array and allows for really quick indexing.</p>
<p>In order to use numpy with Cython, we need to update our compilation script in <code>setup.py</code> to the following:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># setup.py</span>

<span style=color:#f92672>from</span> distutils.core <span style=color:#f92672>import</span> setup
<span style=color:#f92672>from</span> Cython.Build <span style=color:#f92672>import</span> cythonize
<span style=color:#f92672>import</span> numpy

setup(
    ext_modules<span style=color:#f92672>=</span>cythonize(
        <span style=color:#e6db74>&#34;solution_a_cy.pyx&#34;</span>, compiler_directives<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;language_level&#34;</span>: <span style=color:#e6db74>&#34;3&#34;</span>}, annotate<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
    ),
    include_dirs<span style=color:#f92672>=</span>[numpy<span style=color:#f92672>.</span>get_include()],
)
</code></pre></div><p>We&rsquo;ll update our code as follows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cython data-lang=cython><span style=color:#75715e># solution.pyx</span>

<span style=color:#66d9ef>cpdef</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count_increases_cy_array</span>(int[:] depths):
    <span style=color:#66d9ef>cdef</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>increase_counter</span>, <span style=color:#a6e22e>current_depth</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#a6e22e>length</span>, <span style=color:#a6e22e>i</span>
    length <span style=color:#f92672>=</span> depths<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>]
    current_depth <span style=color:#f92672>=</span> depths[<span style=color:#ae81ff>0</span>]
    increase_counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, length):
        <span style=color:#66d9ef>if</span> depths[i] <span style=color:#f92672>&gt;</span> current_depth:
            increase_counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
        current_depth <span style=color:#f92672>=</span> depths[i]
    <span style=color:#66d9ef>return</span> increase_counter
</code></pre></div><p>The first difference is that the type of the argument passed to our function is <code>int[:]</code>, which is the <a href=https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html#syntax>syntax</a> for a <code>memoryview</code> of an array. This might be a little confusing because we&rsquo;re going to actually pass a <code>numpy</code> array as the argument<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>, not a memoryview, but it works regardless. Next, we have some additional variables to create. The two new variables, <code>length</code> and <code>i</code>, allow us to loop through the array and read the value in the array at each index. It&rsquo;s slightly more verbose than depending on the basic <code>for</code> loop, but is required if we&rsquo;re going to use an array in this way.</p>
<p>Let&rsquo;s take a look at the C code generated from this function. I&rsquo;ve expanded the two lines we expanded in the previous image: the for-loop and comparison.</p>
<p><a href=cython-annotate-2.png><img loading=lazy src=cython-annotate-2.png alt="Annotated Cython Code 2">
</a></p>
<p>This is much more readable and it tracks very closely with what we have in the python code. More importantly there are no more calls to python within our loop code. It&rsquo;s doing exactly the simple operation we expect it to: making a comparison between two C <code>int</code>s.</p>
<p>For the final speedup comparison, this version of the function runs in <code>0.157s</code>, an <code>86x</code> speedup compared to the pure-python version.</p>
<h2 id=wrap-up-tempering-expectations>Wrap Up: Tempering Expectations<a hidden class=anchor aria-hidden=true href=#wrap-up-tempering-expectations>#</a></h2>
<p>Optimizing code like this is always a thrilling adventure, but it leads back to my original question: why isn&rsquo;t more stuff written with Cython?</p>
<p>I&rsquo;d like to point out that not all production code is a simple for loop, conditional logic, and a counter. We have a very simple, isolated problem that lent itself well to illustrating the advantages of Cython. Additionally, it certainly takes some time and energy to come up with these improvements. Sure, you can get a <code>2x</code> speedup by compiling your normal python code, but the real value is in an <code>86x</code> speedup on commonly used code.</p>
<p>Let me summarize and rephrase by quoting from the Cython book I&rsquo;m reading, from which I shamelessly stole the &ldquo;Tempering Expectations&rdquo; section name:</p>
<blockquote>
<p>When improving Python’s performance is the goal, the Pareto principle works in our favor: we can expect that approximately 80 percent of a program’s runtime is due to only 20 percent of the code. A corollary to this principle is that the 20 percent is very difficult to locate without profiling.</p>
<p><strong>p. 7</strong></p>
</blockquote>
<p>The fact is: only 16% of <code>spaCy</code> is written in Cython and the rest is python. While that 16% is code that&rsquo;s called very often and a core part of the library, for most everything else using and maintaining python code is much easier to manage. With that python code, we get all the additional features of python plus the rest of the ecosystem. Plus we don&rsquo;t have to consider whether every new feature or component is optimized in Cython or compile a larger part of the library when developing.</p>
<p>In summary, Cython is really cool but I&rsquo;ll only be thinking about using it when:</p>
<ul>
<li>I have profiled my code and identified parts of the code that are slow.</li>
<li>Those parts of the code use mostly python built-in types or numpy arrays.</li>
<li>Those parts of the code are simple so I wouldn&rsquo;t have to spend much time thinking about how to Cython-ize it.</li>
<li>Those parts of the code aren&rsquo;t going to be under frequent future development.</li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>If you&rsquo;re into interactive computing, via <code>ipython</code> or <code>jupyter notebooks</code>, there is a <a href=https://ipython.org/ipython-doc/2/config/extensions/cythonmagic.html><code>%%cython</code></a> magic you can use.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>There is also <a href=https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiling-with-pyximport><code>pyximport</code></a>, which is included with Cython. However, I couldn&rsquo;t get it working in the way I wanted it, so it&rsquo;s not included in this blog post.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p>I have a M1 MBP. For benchmarking, I used the min value of timeit with 5 repeats of 20000 executions.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p>There&rsquo;s also an <a href=https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#grouping-multiple-c-declarations>alternative block syntax</a> for declaring multiple variables.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p>This is the most critical typing required in the function for a speedup. Without this type, we have to infer the type of the object each iteration. If you exclude this typing (but keep all the others), the speedup is back to the compiled python code version at <code>~2.2x</code>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=https://github.com/cython/cython/issues/3797>https://github.com/cython/cython/issues/3797</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:7 role=doc-endnote>
<p>Don&rsquo;t forget to add the conversion of the input to a numpy array to your execution script.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://www.peterbaumgartner.com/>Peter Baumgartner</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
<script data-goatcounter=https://peterbaumgartner.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
</html>